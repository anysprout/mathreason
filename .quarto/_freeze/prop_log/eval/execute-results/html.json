{
  "hash": "5da6ef24302f5496735d7132e37a9c61",
  "result": {
    "markdown": "---\ntitle: \"Propositional Evaluation\"\n---\n\nWe will often need to talk about the rows of a truth-table, and therefore in this section we will introduce some language to help us. In particular, we will identify each row of the truth-table with a variable evaluation. \n\n# Variable Evaluations\n\nTake for example the proposition $P\\lor (Q\\lor R)$. One variable evaluation of this proposition is given by $P^{\\mathcal E}=F,Q^{\\mathcal E} = T, R^{\\mathcal E}=F$. This is just notation for the assignment of $F$ to $P$, and $T$ to $Q$, and $F$ to $R$, and this naturally corresponds to one of the rows of the truth-table.^[The sixth one down, as we have shown the truth-table above.] Note that $\\mathcal E$ is the variable evaluation, and it assigns the values $F,T,F$ to the variables $P,Q,R$ -- from this perspective, $\\mathcal E$ is a function\n\n$$\n\\mathcal E :\\text{Var}\\to \\{T,F\\}\n$$\n\nwhere $\\text{Var}$ is the set of variables which occur in the proposition.^[Note: The notation in $P^{\\mathcal E}$ is just unusual notation, which is really just function evaluation. Usually we write \"the value of the function $f$ on input $x$\" as $f(x)$. For whatever reason, in logic we instead write \"the value of the function $\\mathcal E$ on input $P$\" as $P^{\\mathcal E}$.] So hopefully it makes sense if we now officially define the term. Let $\\alpha$ be any proposition, and $\\text{Var}$ be its set of variables. Then a **variable evaluation** for $\\alpha$ is any function $\\mathcal E:V\\to\\{T,F\\}$ where $\\text{Var}\\subseteq V$.\n\n::: {.callout-important title=\"Find a Variable Evaluation\" appearance=\"minimal\"}\nExercise:\n\nGive any other example of a variable evaluation for $P\\lor (Q\\lor R)$.\n\nIs it possible to have a variable evaluation for $P\\lor (Q\\lor R)$ which is also a variable evaluation for $P\\land Q$? Make sure that you explain why the official definition of a variable evaluation requires $\\text{Var}\\subseteq V$ in order to make sense here.\n:::\n\n# Evaluations\n\nOf course we are not just interested in assigning values to the variables. We are ultimately interested in observing how variable assignments determine a value for the proposition. Returning to the example above, what value does $\\mathcal E$ determine for the proposition $P\\lor (Q\\lor R)$? Well of course we already calculated this in the truth-table, and found that the value is $T$.\n\n## True = 1, False = 0\n\nTo give this an official, technical definition, it will help if we make the identification that $T$ is actually just a symbol for the number 1, and $F$ is actually just a symbol for the number 0. Indeed Python is designed in a way that reflects this reality \"under the hood\" of what $T$ and $F$ really are.\n\n::: {#f23d4b7f .cell execution_count=1}\n``` {.python .cell-code}\nprint(\"1 and 1 = \" + str(1 and 1))\nprint(\"1 and 0 = \" + str(1 and 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 and 1 = 1\n1 and 0 = 0\n```\n:::\n:::\n\n\nWhat the code above shows is that, instead of using booleans `True` and `False`, one could just as well use the numbers 1 and 0 instead, and the behavior will be the same.  In particular, the `and` operator is comfortable being given inputs which are booleans or the numbers 0 and 1.^[Python is also comfortable taking other numbers instead of booleans, but this is not important for our current purposes.  ]\n\nBecause $T$ and $F$ can be regarded as simply the numbers 1 and 0, we will allow ourselves to therefore perform the usual arithmetic operations on them.  That is to say, we will understand that $T+T = 2$ is a true equation, since it merely says $1+1=2$.  Likewise $TF=F$ where we regard the concatenation on the left as multiplication, and so on.  Therefore this equation is true because $1\\cdot 0=0$.  \n\n::: {.callout-important title=\"Boolean Formulas\" appearance=\"minimal\"}\nIn order to compute a particular part of the truth-table for a conjunction, we use the rule that $T\\land T=T$ and $T\\land F = F$ and $F\\land T=F$ and $F\\land F=F$.  But these just say the already familiar computations $1\\cdot 1=1$ and $1\\cdot 0=0$ and $0\\cdot 1=0$ and $0\\cdot 0=0$.  Therefore we can express a formula for computing the conjunction of truth-values:\n\n$$\nx\\land y = x\\cdot y\n$$\n\nConfirm that there is also a formula for disjunction, \n\n$$\nx\\lor y = x+y-xy\n$$\n\n--------------------------\n\nFind a formula for negation.  \n:::\n\n## The Evaluation Definition\n\nWe now have the setup necessary to define an evaluation function.  Let $\\alpha$ be a proposition and $\\mathcal E: V\\to\\{T,F\\}$ any variable evaluation for $\\alpha$. Define the extension of $\\mathcal E$, the function $\\mathcal E^*$, by:\n\n1.  If $P$ is any propositional variable $P\\in V$ then define $P^{\\mathcal E^*}=P^{\\mathcal E}$.^[This merely says: If you want to evaluate a propositional variable, then just use the variable evaluation.  So for instance if $\\mathcal E$ evaluates $P^{\\mathcal E}=T$, then in the extended evaluation, $\\mathcal E^*$, it does exactly the same thing to $P$.  Namely, $P^{\\mathcal E^*}=T$.]\n\n2.  If $\\alpha$ is a formula of the form $\\neg \\beta$ then $\\alpha^{\\mathcal E^*} = 1-\\beta^{\\mathcal E^*}$.^[Explanation: Take for example $\\alpha=\\neg P$.  In this case, then, $\\beta=P$.  Also consider this, with variable evaluation $\\mathcal E$ which evaluates $P^{\\mathcal E}=T$.  <br>\nWhat should we then say is the value of $\\neg P$?  Well it's the negation of $T$, which is $1-T$ which is $F$.  The rule above reflects this, by saying that $(\\neg P)^{\\mathcal E^*} = 1-P^{\\mathcal E^*}$ which is just $1-P^{\\mathcal E} = 1-T$.]\n\n3.  If $\\alpha$ is $\\beta\\lor\\gamma$ then $\\alpha^{\\mathcal E^*} = F$ if $\\beta^{\\mathcal E^*}=F$ and $\\gamma^{\\mathcal E^*}=F$.  Otherwise $\\alpha^{\\mathcal E^*}= T$.  \n4.  For definitions when $\\alpha$ is $\\beta\\land\\gamma,\\beta\\to\\gamma,$ or $\\beta\\leftrightarrow \\gamma$, see the exercises below.  \n\nThis definition is often confusing to a student seeing this for the first time, so let's see the idea in practice -- hopefully if you see it used enough times, you'll actually come to see the definition as quite familiar.  The new kind of formalism being used here, just takes some getting used to.  \n\n::: {.callout-tip title=\"Evaluation Demonstrations\" appearance=\"minimal\"}\n\nLet us consider the propositions \n$$\nP\n$$ \n\nand \n$$\nP\\lor (Q\\lor (\\neg P))\n$$  \n\nWe will also consider the example variable evaluation $\\mathcal E$ given by \n\n$$\nP^{\\mathcal E}=F,Q^{\\mathcal E}=T,R^{\\mathcal E}=F\n$$\n\nLet us use the definition above to find the evaluations $P^{\\mathcal E^*}$ and $(P\\lor (Q\\lor (\\neg P)))^{\\mathcal E^*}$.  \n\n---------------------------\n\nFor the former, this is very simple and immediate.  By clause (1) above, we merely use the variable evaluation. \n\n$$\nP^{\\mathcal E^*} = P^{\\mathcal E} = F\n$$\n\n----------------------------\n\nNow let's find $(P\\lor(Q\\lor (\\neg P)))^{\\mathcal E^*}$.  Because this is a disjunction, we use clause (3), which indicates that we must find the evaluation of each disjunct.\n\nWe first must find the evaluation of the left disjunct, $P^{\\mathcal E^*}$.  But we already did that above and found $P^{\\mathcal E^*}=F$.  \n\nSo we now find the right-hand side $(Q\\lor(\\neg P))^{\\mathcal E^*}$.  To find this again we need to find the values on either side of the $\\lor$.  From a calculation like before, we find that $Q^{\\mathcal E^*}=T$.  \n\nIn order to find $(\\neg P)^{\\mathcal E^*}$ we use clause 2.  This tells us that \n\n$$\n(\\neg P)^{\\mathcal E^*} = 1-P^{\\mathcal E^*} = 1-F = 1\n$$\n\nwhere the first equality is due to clause 2, the second is due to our earlier calcuation, and the last is because $F$ is the same as 0.  \n\nNow we can find \n\n$$\n(Q\\lor(\\neg P))^{\\mathcal E^*} = T\n$$\n\nby clause 3, because we know that not both sides of the disjunction evaluated to false (in fact both evaluated to true).  \n\nFinally we can now decide \n\n$$\n(P\\lor(Q\\lor (\\neg P)))^{\\mathcal E^*} = T\n$$\n\nbecause by clause 3, not both sides evaluated to false (the left evaluated to false but the right evaluated to true).  \n:::\n\n::: {.callout-important title=\"Now You Evaluate\" appearance=\"minimal\"}\n\nUsing the same variable evaluation $\\mathcal E$ above, find $(P\\lor (\\neg R))^{\\mathcal E^*}$.  \n\n:::\n\n::: {.callout-important title=\"Other Evaluation Rules\" appearance=\"minimal\"}\n\nI left the rule for the evaluation of, for instance, $P\\land Q$, unspecified.  However, as you can see from the rule for $\\lor$, this rule merely takes the evaluation of the left-hand disjunct, and the right-hand disjunct, and \"puts them together\" in the way that we're familiar with from the truth-table.  \n\nCome write down a rule for conjunction, like the one I explicitly gave for disjunction.  Then use it to evaluate $P\\land Q$ using the same variable evaluation as above.  \n\nThen do likewise for $\\to$ and $\\leftrightarrow$.  Make up your own examples to exercise these ideas.  \n\n:::\n\n# A Python Evaluation Implementation\n\nWe can implement the evaluator in code, using what we built previously for the parse tree!  First we must reproduce all of the code used to take an input string and produce its parse tree.  But we will agument the classes with an `eval` function, reflected by the rules above.\n\n::: {#a18e9e08 .cell execution_count=2}\n``` {.python .cell-code}\nimport pyparsing\n\nclass Proposition:\n    pass\n\nclass PropVariable(Proposition):\n    def __init__(self, v):\n        assert (type(v) == type(\"\") and len(v) == 1) \n        self.v = v\n    def __str__(self):\n        return(self.v)\n    def eval(self, prop_eval):\n        return prop_eval(self.v)\n\nclass Negation(Proposition):\n    def __init__(self, beta):\n        assert issubclass(type(beta),Proposition)\n        self.neg = beta\n    def __str__(self):\n        return(\"(not \" + str(self.neg) + \")\")\n    def eval(self, prop_eval):\n        return(1 - self.neg.eval(prop_eval))\n\nclass Disjunction(Proposition):\n    def __init__(self, beta, gamma):\n        assert issubclass(type(beta),Proposition) \\\n            and issubclass(type(gamma),Proposition)\n        self.left, self.right = beta, gamma\n    def __str__(self):\n        return(\"(\" + str(self.left )+\" or \" + str(self.right) + \")\")\n    def eval(self, prop_eval):\n        l, r = self.left.eval(prop_eval), self.right.eval(prop_eval)\n        return( l + r - l*r )\n\ndef parseTree(p):\n    if type(p) == type(\"\"):\n        return PropVariable(p)\n    if len(p) == 1:\n        return parseTree(p[0])\n    if len(p) == 2:\n        assert( p[0] == \"not\" )\n        return Negation(parseTree(p[1]))\n    \n    if len(p) == 3:\n        if p[1] == \"or\": return Disjunction(parseTree(p[0]), parseTree(p[2]))\n        raise Exception(\"length 3 list but unrecognized middle token\")\n    raise Exception(\"length of list unrecognized\")\n\nterms = pyparsing.Word(pyparsing.alphas) | \"not\" | \"and\" | \"or\" | \"if\" | \"then\" | \"iff\" \nnesting = pyparsing.nestedExpr( '(', ')', content=terms )\n\ndef shape(s): \n    p = nesting.parseString(\"(\"+s+\")\")[0]\n    \n    return parseTree(p)\n```\n:::\n\n\nIn order to run the code below, one will have to first run the code above.  \n\nIn the code below, we will write an evaluation function which essentially just reproduces the rules above, but implemented on the `Proposition` objects from before.  \n\nOf course, now we need a new object in our program, to represent the variable evaluation.  This will be a function which returns `True` for some instances of `PropVariable` and `False` for others.  Below is one example of a variable evaluation, which returns `True` for `P` and `False` for everything else.\n\n::: {#d11d4808 .cell execution_count=3}\n``` {.python .cell-code}\ndef vareval(pv):\n    return pv == \"P\"\n```\n:::\n\n\nAnd now here is the `eval` function.  Note that it takes two arguments, a string representing a proposition, and a propositional evaluation.  \n\n::: {#2e0f5b19 .cell execution_count=4}\n``` {.python .cell-code}\ndef eval(prop_string, prop_eval):\n    return bool((shape(prop_string)).eval(prop_eval))\n```\n:::\n\n\nand finally we can demonstrate the code's behavior:\n\n::: {#16f92f37 .cell execution_count=5}\n``` {.python .cell-code}\nprop_string = \"Q or (not (not P))\"\n\nprint(eval(prop_string,vareval))\n\nprint(eval(prop_string, lambda x: False))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n```\n:::\n:::\n\n\n::: {.callout-important title=\"Extend Evaluation\" appearance=\"minimal\"}\n\nExtend the `eval` function to handle conjunction, conditional, and biconditional propositions.\n\n:::\n\n",
    "supporting": [
      "eval_files"
    ],
    "filters": [],
    "includes": {}
  }
}