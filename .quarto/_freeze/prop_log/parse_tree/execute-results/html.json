{
  "hash": "c5faa2d3db2e7461f226648d7394f35c",
  "result": {
    "markdown": "---\ntitle: \"Parse Trees\"\n---\n\nThe ambiguity between $\\neg(P\\lor Q)$ and $(\\neg P)\\lor Q$ makes visible the need for the idea of a \"parse tree\". To see what a parse tree is, let's start with the example of the simpler proposition $P\\lor Q$.\n\n\n```{dot}\n//| fig-height: 2\n//| fig-width: 4\n\ngraph G {\n    v -- P;\n    v -- Q;\n}\n```\n\n\nThis just expresses that the $\\lor$ is \"bound\" directly to the sub-propositions $P$ and $Q$. More interesting is the parse tree for $\\neg(P\\lor Q)$. I've produced it below -- in a later version of this text I will try to properly typeset the $\\neg$ symbol, but for now I merely use the dash, `-`, instead.\n\n\n```{dot}\n//| fig-height: 2\n//| fig-width: 4\n\ngraph G {\n    \"-\" -- v\n    v -- P\n    v -- Q\n}\n```\n\n\nThis illustrates that the symbol $\\neg$ is applied to the entire formula $P\\lor Q$, which itself is represented as a subtree of the parse tree.\n\n::: {.callout-important title=\"Parse Tree Basic\" appearance=\"minimal\"}\nExercise:\n\nDraw the parse trees for $(\\neg P)\\lor Q$ and $P\\lor (Q\\lor R)$ and $(P\\lor Q)\\lor R$ and $(\\neg (P \\lor Q)) \\lor (\\neg (Q\\lor R))$.\n:::\n\n# The Main Operator\n\nWe are now in a position to define the concept of the main operator of a proposition. Take for example $\\neg P \\land (Q\\to \\neg R)$. Fundamentally, this is the conjunction of $\\neg P$ on the left and $Q\\to \\neg R$ on the right. Therefore the main operator of this proposition is $\\land$.\n\nBut the question is: Given a formula, how do you identify its main operator? One answer is that it is the \"root\" of the parse tree. Let's draw the parse tree for this formula. Note that because negation takes precedence, then we may start by regarding $\\neg P$ as a sub-proposition here, and it has parse tree\n\n\n```{dot}\n//| fig-height: 2\n//| fig-width: 4\n\ngraph G {\n    \"-\" -- P\n}\n```\n\n\nNow as we scan the rest of the proposition, the parentheses tell us that we must regard the $\\land$ as \"reading\" $Q\\to \\neg R$ on its right. Now this is a conditional with $Q$ to its left and $\\neg R$ to its right. This whole thing has parse tree\n\n\n```{dot}\n//| fig-height: 2\n//| fig-width: 4\n\ngraph G {\n    \"->\" -- Q;\n    \"->\" -- \"-\";\n    \"-\" -- R;\n}\n```\n\n\nNow that we see the two sub-parse-trees, we can \"glue them together\" with $\\land$.\n\n\n```{dot}\n//| fig-height: 2\n//| fig-width: 4\n\ngraph G {\n    onp[label = \"-\"];\n    onr[label = \"-\"];\n\n    subgraph arrow {\n        \"->\" -- Q;\n        \"->\" -- onr;\n        onr -- R;\n    }\n\n    \"/\\\\\" -- onp;\n    onp -- P;\n    \"/\\\\\" -- \"->\";\n\n    {\n        rank = same;\n        edge[style = invis]\n        Q -- onr\n    }\n}\n```\n\n\nNow that we have the entire parse tree, we can say that the **main operator** of the proposition is its root node in the parse tree. In this particular example, the main operator is $\\land$.\n\n::: {.callout-important title=\"Main Op Ex\" appearance=\"minimal\"}\nExercise:\n\nMake up a complex example proposition and find its main operator.\n:::\n\n# A Python Parser\n\nIn this section we will see how you can make Python understand the parse tree of a proposition.  We will implement a function which, given an input string, will return an instance of a `Proposition` class representing the hierarchical structure of the proposition.  \n\n## Representation\n\nThis will first require us to make two decisions: How do we represent the input proposition, and how do we represent the output tree?\n\nThe input propositions will be represented by strings and lists.  It's easiest just to give some examples.  \n\n* `\"P\"` represents the propositional variable $P$.\n* `[\"not\", \"P\"]` represents $\\neg P$.\n* `[[\"not\", \"P\"], \"or\", \"Q\"]` represents $(\\neg P)\\lor Q$.  \n\n::: {.callout-important title=\"Proposition Representation\" appearance=\"minimal\"}\nGive the code representation of the propostion $\\neg(\\neg P)$.  \n:::\n\nThe output tree structure will be represented by classes.  We will have a class `PropVariable` for propositional variables.  This class will contain only a single piece of information, `self.v`, a string which is the name of the propositional variable.\n\nWe will have a `Negation` class which represents the negation of some other proposition.  This will contain a single piece of information, `self.neg`, which is the tree structure of the proposition that is negated.  \n\nThen we will have a `Disjunction` class which represents the disjunction of two propositions.  It contains two pieces of information, `self.left` and `self.right`, representing the two disjuncts.  \n\nIt will also be useful to have an abstract class `Proposition` which gives these three classes a common superclass.[^1]\n\n[^1]: This abstract class is not strictly necessary for the code to work.  However, I like to check the inputs to the functions, to make sure that they have the right types.  The abstract class allows us to regard each kind of proposition as a subclass of this larger abstract class -- and this makes it possible to check an input to ensure that it is some kind of proposition.   \n\n::: {#a1800114 .cell execution_count=1}\n``` {.python .cell-code}\nclass Proposition:\n    pass\n\nclass PropVariable(Proposition):\n    def __init__(self, v):\n        assert (type(v) == str and len(v) == 1) \n        self.v = v\n    def __str__(self):\n        return(self.v)\n\nclass Negation(Proposition):\n    def __init__(self, beta):\n        assert issubclass(type(beta),Proposition)\n        self.neg = beta\n    def __str__(self):\n        return(\"(not \" + str(self.neg) + \")\")\n\nclass Disjunction(Proposition):\n    def __init__(self, beta, gamma):\n        assert issubclass(type(beta),Proposition) \\\n            and issubclass(type(gamma),Proposition)\n        self.left, self.right = beta, gamma\n    def __str__(self):\n        return(\"(\"+str(self.left)+\" or \" + str(self.right) + \")\")\n```\n:::\n\n\n::: {.callout-important title=\"Other Op Classes\" appearance=\"minimal\"}\nWrite new classes in addition to the ones above, for conjunction, conditional, and biconditional propositions.  (Hint: These are all almost exactly the same as `Disjunction`.)\n:::\n\n::: {.callout-important title=\"Make Proposition Instances\" appearance=\"minimal\"}\nThe following code makes instances of these classes and prints their string representations.  \n\n::: {#666de0b9 .cell execution_count=2}\n``` {.python .cell-code}\np = PropVariable(\"P\")\nnp = Negation(p)\nnpop = Disjunction(np,p)\n\nprint(str(p))\nprint(str(np))\nprint(str(npop))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nP\n(not P)\n((not P) or P)\n```\n:::\n:::\n\n\nCreate an instance of these classes, which represents $(\\neg Q)\\land (\\neg P)$.  \n:::\n\n## Structuring\n\nThe above was necessary to make the Python code work.  But it was not the most interesting for the analysis of logic.  The function below is the code that most reflects the idea of the parse tree.  This takes a proposition, represented as we have described, and returns a tree structure, as we have defined with the `Proposition` class.  \n\n::: {#268d60f4 .cell execution_count=3}\n``` {.python .cell-code}\ndef parseTree(p):\n    \n    if type(p) == type(\"\"):\n        return PropVariable(p)\n    \n    if len(p) == 2:\n        assert( p[0] == \"not\" )\n        return Negation(parseTree(p[1]))\n    \n    if len(p) == 3:\n        if p[1] == \"or\": return Disjunction(parseTree(p[0]), parseTree(p[2]))\n        raise Exception(\"length 3 list but unrecognized middle token\")\n    raise Exception(\"length of list unrecognized\")\n```\n:::\n\n\n::: {.callout-important title=\"Explain parseTree\" appearance=\"minimal\"}\nExplain the lines of code \n\n::: {#b555ea02 .cell execution_count=4}\n``` {.python .cell-code}\nif type(p) == type(\"\"):\n    return PropVariable(p)\n\n```\n:::\n\n\n-----------------------------------\n\nExplain \n\n::: {#f5b6cb64 .cell execution_count=5}\n``` {.python .cell-code}\nif len(p) == 2:\n    return Negation(pthelper(p[1]))\n```\n:::\n\n\n(Note: I have omitted the \"assertion\", since this is there mostly for debugging purposes -- it is not especially interesting for the logic.)\n\n---------------------------------------\n\nExplain \n\n::: {#ccd88818 .cell execution_count=6}\n``` {.python .cell-code}\nif len(p) == 3:\n    if p[1] == \"or\": return Disjunction(pthelper(p[0]), pthelper(p[2]))\n```\n:::\n\n\n:::\n\n::: {.callout-important title=\"Other parseTree Operations\" appearance=\"minimal\"}\nExtend the code of the `parseTree` function to make it parse conjunction, conditional, and biconditional propositions.  For conjunction, use the \"token\" to be \"and\" rather than \"or\".  For biconditional, use the toke \"iff\" rather than \"or\".\n\nFor the conditional, we will take its representation to be a little different.  In order to represent $P\\to Q$ we will represent this in code as `[\"if\", \"P\", \"then\", \"Q\"]`.  Therefore the way that you will need to edit the code for the conditional is a bit different from the others.  \n:::\n\n## Parsing\n\nIt can be a little unsatisfying to input propositions in such an artificial way.  Can't we find a way to input a string like `\"if (not P) then (Q or (R and S))\" and the program will structure it and form the corresponding tree?  Indeed it can be done and the code below accomplishes this!  \n\nHowever, to understand it, you have to get a little familiar with the `pyparsing` library.  Since none of this is very interesting for logic, I'll just leave the code but won't try to explain it.\n\n::: {#9020c753 .cell execution_count=7}\n``` {.python .cell-code}\nimport pyparsing\n\nterms = pyparsing.Word(pyparsing.alphas) | \"not\" | \"and\" | \"or\" | \"if\" | \"then\" | \"iff\" \nnesting = pyparsing.nestedExpr( '(', ')', content=terms)\n\ndef shape(s): \n    p = nesting.parseString(\"(\"+s+\")\")[0]\n    \n    return parseTree(p)\n```\n:::\n\n\n",
    "supporting": [
      "parse_tree_files"
    ],
    "filters": [],
    "includes": {}
  }
}