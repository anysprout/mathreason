{"title":"Abstract Propositions","markdown":{"yaml":{"title":"Abstract Propositions"},"headingText":"Propositional Variables","containsRefs":false,"markdown":"\n\nWe looked at two examples of arguments in the previous section, but we don't want to be too focused on specific cases. Eventually we want to analyze logic itself, so that it can be applied to any propositions that may come up.\n\n\nWe will write an abstract proposition with a variable, like $P$.  What this means is that $P$ could be any proposition, and we don't know which it is.  So for instance $P$ could represent $x=1$ or \"Russia is large\", or any other assertion that could be true or false.  \n\nBecause we don't know whether an abstract proposition is true or false, we represent this in a table.  In the table below, naturally we use $T$ to denote \"true\" and $F$ to denote \"false\".\n\n$$\n\\begin{array}{|c|} \\hline \nP \\\\ \\hline\nT \\\\ \\hline\nF \\\\ \\hline\n\\end{array}\n$$\n\nFor now, the table may seem like making too big a deal over a small thing. As the abstract propositions get more complex, though, the tables will help us to manage that complexity. So if this doesn't make sense right now, don't worry too much about it. As you see the table really do its job in the next few subsections, it will make more sense.\n\n# Truth-functional Connectives\n\nA propositional variable by itself is boring. The way that we will analyze arguments is by breaking it into its component sentences. These sentences are themselves formed by joining together simpler sentences. Take for instance\n\n> Either $x=1$ or $x\\ne 1$.\n\nAlign the sentence $x=1$ with the propositional variable $P$, and $x\\ne 1$ with the sentence $Q$. Then the sentence in the quote-block above is \"$P$ or $Q$\". This is an example of a sentence which is formed by joining together simpler sentences.\n\n## Negation\n\nOne way to form a new proposition from the variable $P$ is to negate it. If the proposition $P$ is aligned with $x=1$ then its negation is \"$x$ is not equal to 1\", or in more standard mathematical notation, $x\\ne 1$. This flips the truth-value of the proposition being negated.\n\nTo represent the negation of $P$ we write $\\neg P$.\n\nBelow is the truth-table for negation. \n\n$$\n\\begin{array}{|c||c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P & \\neg  P \\\\ \\hline \\\\\\hline\nT & \\color{red}F  \\\\ \\hline\nF & \\color{red}T  \\\\ \\hline\n\\end{array}\n$$\n\nNow that the table is getting sophisticated, I'm adding some extra features. First of all, I've shaed the first row and column with a gray background.  This is to indicate that the first row is a header row.  Also the first column as a kind of header column, because we will just use it to \"index\" the entries in the body of the truth table.  \n\nThe first \"real\" content of the table is emphasized below.  \n\n$$\n\\begin{array}{|c||c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P & \\neg  P \\\\ \\hline \\\\\\hline\nT & \\bf \\color{red}F  \\\\ \\hline\nF & \\color{red}T  \\\\ \\hline\n\\end{array}\n$$\n\nThis is computed by first finding the value $P$, which is $T$ on this row.  Then we apply the $\\neg$ operation to it, flipping it to $F$ and hence this is the value.  The second row of truth-values is computed similarly.  \n\n::: {.callout-important title=\"Double Negation\" appearance=\"minimal\"}\nExercise:\n\nMake the truth-table for $\\neg (\\neg P)$.\n\nWe say that two propositions are **equivalent** if they \"have the same truth-table\".[^2] Are $P$ and $\\neg(\\neg P)$ equivalent?\n:::\n\n[^2]: Having the same truth-table means: They have the same truth-value at every row of the table.\n\n------------------------------------------------------------------------\n\nNegation is also represented in almost every programming language. Below we can see how Python represents truth values, and then see how Python gives the ability to negate them.\n\n```{python}\nprint(not True)\nprint(not False)\n```\n\n::: {.callout-important title=\"DN in Python\" appearance=\"minimal\"}\nExercise:\n\nDemonstrate double-negation (i.e. the equivalence of $P$ and $\\neg(\\neg P)$) in a Python program.\n:::\n\n## Disjunction\n\nIf $P$ and $Q$ are any two propositional variables, then to express \"$P$ or $Q$\" we write $P\\lor Q$. Note that by saying that either sentence is true, it is enough if just one of them is true. Take for example the sentence \"Either the prize is behind the first door or the second door.\" If the prize is behind the first door, then that sentence was true. But if the prize was behind the third door (i.e. not the first and not the second), the sentence was false.\n\nThis is called the **disjunction** of $P$ and $Q$, and it has the following truth-table.\n\n$$\n\\begin{array}{|c|c|ccc|}\\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&Q\\columncolor{lightgray}&P&\\lor &Q\\\\\\hline&&&&\\\\\\hline\nT&T&&\\color{red}T&\\\\\\hline\nT&F&&\\color{red}T&\\\\\\hline\nF&T&&\\color{red}T&\\\\\\hline\nF&F&&\\color{red}F&\\\\\\hline\n\\end{array}\n$$\n\nNote that this time the table has four rows (not counting the header row which declares the variables and proposition). This is because there are more possibilities with two variables than with just one. We could have both $P$ and $Q$ true, which is the first row -- or we could have one true and the other false, which is the next two rows -- or both could be false, which is the final row.\n\nIn Python we can model this with the disjunction operator.\n\n```{python}\nprint(True or True)\nprint(True or False)\nprint(False or True)\nprint(False or False)\n```\n\nIn fact, the above can be done more simply in a couple of \"embedded for-loops\", as shown below.\n\n```{python}\ntruth_values = [True, False] # A list of all truth values\nfor P in truth_values: # Iterate through all truth values\n    for Q in truth_values: # Q does likewise\n        print(P or Q) # Compute \"their 'or'\" and print it.\n```\n\nThe way that the above code works is: `P` is a variable, and it will eventually \"take\" every value from the list `[True,False]`. Initially it takes the value `True`.\n\nAfter `P` takes `True` then the code inside, `for Q in [True,False]: print(P or Q)` executes. But the way that this executes is, similarly, that `Q` starts by taking the value `True`. Then the program executes `print(P or Q)` which is effectively equivalent to `print(True or True)`.\n\nMaking a long story short, on the next loop iteration, `P` is still true but `Q` takes the value `False`. Then `print(P or Q)` executes, which is equivalent to `print(True or False)`. Then `P` ticks over to `False` and `Q` starts over at `True`, and `print(P or Q)` is equivalent to `print(False or True)`. Then `P` is `False` and `Q` takes `True`, and `print(P or Q)` is equivalent to `print(False or False)`.\n\n::: {.callout-important title=\"Not Loop\" appearance=\"minimal\"}\nExercise:\n\nThis code:\n\n```{python}\nprint(not True)\nprint(not False)\n```\n\ncould instead be implemented with a for-loop.  Fill in the parts of the following code where it contains `%TODO` so that it does the same thing as the code above.\n\n```{python}\nfor P in [True, False]:\n    \"\\%TODO\"\n```\n:::\n\n------------------------------------------------------------------------\n\nIf we use three variables, we can analyze the sentence $P\\lor (Q\\lor R)$. This now requires even more rows of truth-values. How many more?\n\nWell it should *double* the number of rows, from how many were needed for two variables. That is because we need to consider two possibilities: Either $P$ is true or it is false. If $P$ is true, then we need to run through all of the remaining four possibilities for $Q$ and $R$. So this half of the truth-table should look like:\n\n$$\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nT&T&T\\\\\\hline\nT&T&F\\\\\\hline\nT&F&T\\\\\\hline\nT&F&F\\\\\\hline\n\\end{array}\n$$\n\nThen it's clear what we do for the other half, where $P$ is $F$.\n\n$$\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nF&T&T\\\\\\hline\nF&T&F\\\\\\hline\nF&F&T\\\\\\hline\nF&F&F\\\\\\hline\n\\end{array}\n$$\n\nPutting these together we get the eight-row truth-table\n\n$$\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nT&T&T\\\\\\hline\nT&T&F\\\\\\hline\nT&F&T\\\\\\hline\nT&F&F\\\\\\hline\nF&T&T\\\\\\hline\nF&T&F\\\\\\hline\nF&F&T\\\\\\hline\nF&F&F\\\\\\hline\n\\end{array}\n$$\n\n::: {.callout-important title=\"General Row Numbers\" appearance=\"minimal\"}\nExercise:\n\nIf there were 4 variables, how many rows would be needed?  (Hint: One variable required two rows.  Two variables, four rows; three variables, eight row; ...)\n\nIf there were $n$ variables, how many rows would be needed?\n:::\n\nNow that we know the column and row \"headers\" (I am regarding each of the first three columns as a kind of header column.) we can fill in the table for $P\\lor Q\\lor R$. However, doing it all at once can be difficult to parse, so let's do this in stages. First let's merely populate the columns under the variables -- this is a tedious transcription.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\nP&Q&R&&P&\\lor &(Q&\\lor &R)\\\\\\hline\\\\\\hline\nT&T&T && T &  & T &  & T\\\\\\hline\nT&T&F && T &  & T &  & F\\\\\\hline\nT&F&T && T &  & F &  & T\\\\\\hline\nT&F&F && T &  & F &  & F\\\\\\hline\nF&T&T && F &  & T &  & T\\\\\\hline\nF&T&F && F &  & T &  & F\\\\\\hline\nF&F&T && F &  & F &  & T\\\\\\hline\nF&F&F && F &  & F &  & F\\\\\\hline\n\\end{array}\n$$\n\nNow we try to fill in the values under any operators. However, if we look at the first $\\lor$ operator, we cannot fill it in! This is because it must \"read\" the value to its left and right. The values to the left are there, but the values to the right come from everything inside $(Q\\lor R)$. These values should be read from what appears under the $\\lor$ and they are blank. Therefore we must fill these in first.\n\nTo fill in the values under $(Q\\lor R)$, we get the following table. Notice that the first row is computed as $T\\lor T=T$. The second is $T\\lor F=T$ and the third is $F\\lor T = T$ and the fourth is $F\\lor F=F$, and so on. Because this column of computation is derived from others, I will color it.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\nP&Q&R&&P&\\lor &(Q&\\lor &R)\\\\\\hline\\\\\\hline\nT&T&T && T &  & T & \\color{blue}T & T\\\\\\hline\nT&T&F && T &  & T & \\color{blue}T & F\\\\\\hline\nT&F&T && T &  & F & \\color{blue}T & T\\\\\\hline\nT&F&F && T &  & F & \\color{blue}F & F\\\\\\hline\nF&T&T && F &  & T & \\color{blue}T & T\\\\\\hline\nF&T&F && F &  & T & \\color{blue}T & F\\\\\\hline\nF&F&T && F &  & F & \\color{blue}T & T\\\\\\hline\nF&F&F && F &  & F & \\color{blue}F & F\\\\\\hline\n\\end{array}\n$$\n\nAnd now that this column has been populated, the column under the first $\\lor$ now \"sees\" all the values that it needs to compute. Therefore we do this in the table below. Note that the first row is computed as $T\\lor{\\color{blue} T}=\\color{red}T$, and the fourth row is computed as $T\\lor {\\color{blue} F}=\\color{red} T$, for two illustrations.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\nP&Q&R&&P&\\lor &(Q&\\lor &R)\\\\\\hline\\\\\\hline\nT&T&T && T & \\color{red}T & T & \\color{blue}T & T\\\\\\hline\nT&T&F && T & \\color{red}T & T & \\color{blue}T & F\\\\\\hline\nT&F&T && T & \\color{red}T & F & \\color{blue}T & T\\\\\\hline\nT&F&F && T & \\color{red}T & F & \\color{blue}F & F\\\\\\hline\nF&T&T && F & \\color{red}T & T & \\color{blue}T & T\\\\\\hline\nF&T&F && F & \\color{red}T & T & \\color{blue}T & F\\\\\\hline\nF&F&T && F & \\color{red}T & F & \\color{blue}T & T\\\\\\hline\nF&F&F && F & \\color{red}F & F & \\color{blue}F & F\\\\\\hline\n\\end{array}\n$$\n\n::: {.callout-important title=\"Python Triple Disjunction\" appearance=\"minimal\"}\nExercise:\n\nDemonstrate a couple of rows of the truth-table above in some Python code. For instance, run stuff like `True or (False or False)`.\n\nThen write a triple-for-loop to reproduce the entire truth-table.\n:::\n\n::: {.callout-important title=\"Finite Disjunction\" appearance=\"minimal\"}\nExercise:\n\nNotice that the only row at which $P\\lor(Q\\lor R)$ is $F$ is the final row. That's also true for $P\\lor Q$. In fact, if you make the truth-table for $P\\lor (Q\\lor (R\\lor S))$ it will be the same.\n\nWrite a Python program to demonstrate this.\n\n------------------------------------------------------------------------\n\nIn general, a disjunction of $n$ variables will be true if how many of the variables take the value $T$?\n:::\n\n::: {.callout-important title=\"Disjunction Associativity\" appearance=\"minimal\"}\nExercise:\n\nI claim that $P\\lor (Q\\lor R)$ is equivalent to $(P\\lor Q)\\lor R$. Write a Python program to prove that this is true.\n\nThis fact is called the **associativity** of disjunction.\n\n------------------------------------------------------------------------\n\nI also claim that disjunction is **commutative** which means $P\\lor Q$ is equivalent to $Q\\lor P$. Write a Python program to prove that this is true.\n:::\n\n::: {.callout-important title=\"Parsing Ambiguity\" appearance=\"minimal\"}\nExercise:\n\nMake a truth table for both $\\neg (P\\lor Q)$ and $(\\neg P)\\lor Q$, and check your answers with the following Python code.\n\n```{python echo=True}\nfor P in [True, False]:\n    for Q in [True, False]:\n        print(not (P or Q))\n\nprint() # Just print a blank line to help see the separation of the two tables.\n\nfor P in [True, False]:\n    for Q in [True, False]:\n        print((not P) or Q)\n```\n\nThen use these two truth-tables to argue that these two propositions are **not** equivalent.\n\nUse the above result to argue that $\\neg P\\lor Q$ is meaningless.\n\nHowever, although $\\neg P\\lor Q$ is technically meaningless, we will in fact assume that if we ever write $\\neg P\\lor Q$ it is actually short-hand for $(\\neg P)\\lor Q$. The more general rule is that\n\n> Negation takes precedence.\n\nThat is to say, in any abstract logical expression in which negation occurs, we will assume that it applies *first*.\n\nAnd technically $P\\lor Q\\lor R$ is meaningless because we technically require parentheses to distinguish between $P\\lor (Q\\lor R)$ and $(P\\lor Q)\\lor R$. However, since we have seen that these are equivalent, then we may understand $P\\lor Q\\lor R$ as shorthand for either of these -- and it doesn't matter which one. Therefore this, too, will be our convention. That is to say, we will gladly write $P\\lor Q\\lor R$ and allow the reader to interpret this as either $P\\lor (Q\\lor R)$ or $(P\\lor Q)\\lor R$, whichever is their favorite.\n:::\n\n\n\n## Conjunction\n\nHaving done all that work for disjunction, conjunction is mostly trivial. It represents the proposition \"$P$ and $Q$\", we write this symbolically as $P\\land Q$, and it has the following truth-table.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|}\\hline\nP&Q&&P&\\land &Q\\\\\\hline\\\\\\hline\nT&T&&T&\\color{red}T&T\\\\\\hline\nT&F&&T&\\color{red}F&F\\\\\\hline\nF&T&&F&\\color{red}F&T\\\\\\hline\nF&F&&F&\\color{red}F&F\\\\\\hline\n\\end{array}\n$$\n\n::: {.callout-important title=\"Conjunction Catchall\" appearance=\"minimal\"}\nExercise:\n\nRe-do all the exercises for disjunction but this time for conjunction, noting any interesting dissimilarities.\n:::\n\n::: {.callout-important title=\"Distribution\" appearance=\"minimal\"}\nExercise:\n\nShow (either in a table or a program) that $P\\land (Q\\lor R)$ is **not** equivalent to $(P\\land Q)\\lor R$ and conclude that \"conjunction and disjunction do not associate\".[^5]\n\nHowever, show that $P\\land (Q\\lor R)$ is equivalent to $(P\\land Q) \\lor (P\\land R)$. Also, come up with a corresponding equivalence for $P\\lor (Q\\land R)$ and prove that it's equivalent.\n\nThe above is called the **distribution** of $\\land$ over $\\lor$ (and conversely). This is similar to how multiplication distributes over addition.\n\n$$ \nx(y+z) = xy+xz \n$$\n\nHowever, note that addition does **not** distribute over multiplication.\n\n$$\nx+yz \\ne (x+y)(x+z)\n$$\n\nTherefore these logical operators are \"more distributive\" than the mathematical operators. Each distributes over the other, whereas in mathematics, it is only that multiplication distributes over addition.\n:::\n\n[^5]: It may take an act of interpretation to know exactly what is being asked here. But to say that \"conjunction and disjunction do not associate\", means that if an expression has both symbols, then you cannot merely switch around the parentheses.\n\n## The Conditional\n\nThe conditional is, in a sense, no different from the other logical symbols. It is meant to represent propositions of the form \"If $P$ then $Q$.\" It has symbol $\\to$ and truth-table\n\n$$\n\\begin{array}{|c|c|c|c|c|c|}\\hline\nP&Q&&P&\\to &Q\\\\\\hline\\\\\\hline\nT&T&&T&\\color{red}T&T\\\\\\hline\nT&F&&T&\\color{red}F&F\\\\\\hline\nF&T&&F&\\color{red}T&T\\\\\\hline\nF&F&&F&\\color{red}T&F\\\\\\hline\n\\end{array}\n$$\n\nHowever, this truth-table is probably perplexing. Let's try to see the correspondence between a sentence of the form \"If $P$ then $Q$.\" and this truth-table. Consider these four examples:\n\n::: {.callout-note title=\"If Then Example\" appearance=\"minimal\"}\nExample:\n\nIf the sun is out, then the weather is warm.\n:::\n\nNow consider each of the four possibilities. The first is that the sun is out and the weather is warm. Well, it makes sense that the sentence was true in this case. This explains the first row, since we aligned $P$ with a true sentence, $Q$ with a true sentence, and the result is a true sentence.\n\nNext consider the possibility that the sun is out, but because you live in the South Pole, the weather is cold. In this case, the sentence was false. This explains the second row since $P$ is true and $Q$ false.\n\nSo far I think everything makes pretty immediate sense, but the next two possibilities are the ones that most people struggle with the most. What is especially difficult about them is that $P$ is false. A sentence of the form \"If $P$ then $Q$.\" is quite literally predicated upon the assumption of $P$, so it becomes quite difficult to think about what one should say if $P$ is false.\n\nIn the table, it is clear that we have decided that, when $P$ is false, the conditional sentence is true (regardless of the truth-value of $Q$). You can imagine that it behaves like a promise: \"I promise that, IF the sun is out, then the weather is warm.\" When the condition of the promise is removed, because say the sun is not out, then the promise is so-to-speak nullified -- and we say that the speaker was speaking the truth.\n\nIn the example of the sun and the weather, imagine the \"false-true\" case in which the sun is not out but the weather is still warm. In that case, we regard the speaker as not wrong, because the condition of the sentence was not met. And similarly, in the false-false case whether the sun is not out and the weather is not warm, again the speaker is still speaking the truth.[^6]\n\n[^6]: The entire topic of the conditional is, in fact, a giant philosophical mess. There has been an enormous literature in linguistics and philosophy on the precise meaning and \"truth-conditions\" for conditional sentences. The resounding agreement among specialists, is that natural languages do not use a truth-functional conditional. That is to say, real languages have a meaning to their conditional sentences, which cannot be captured in a truth-table. Therefore one should regard the conditional that we use in mathematics as a kind of \"formal language\" rather than a natural language.\n\n::: {.callout-important title=\"Conditional Properties\" appearance=\"minimal\"}\nShow that the conditional is neither associative nor commutative.\n:::\n\nBesides having the most confusing truth-table, the conditional also is the hardest to translate to and from natural language. Of course if we say \"If a polygon has three angles then it is a triangle,\" then we would align $P$ with the sentence \"the polygon has three angles\" and $Q$ with \"the polygon is a triangle\". The the entire proposition is aligned with $P\\to Q$.\n\nHowever, the first clause is not always the one that goes to the left of the $\\to$. The example sentence is equivalent to \"The polygon is a triangle if it has three angles.\" This makes it seem as though the clause after the word \"if\" will always appear to the left of the $\\to$.\n\nHowever, even this is not true! The sentence \"The polygon is a triangle only if it has three angles\" is equivalent to \"If the polygon is a triangle then it has three angles\"! This one is often especially confusing to a new student, learning about the conditional.\n\nTo help make the \"only if\" construction clearer, imagine a castle which is only accessible by a bridge, which is guarded by a knight.\n\n![](/_site/prop_log\\images\\knight.png){fig-align=\"left\" width=\"204\"}\n\nThen the sentence \"You can enter the castle only if you take the bridge\" can be stated as the if-then sentence\n\n> If you are in the castle then you took the bridge.\n\nNote that the reverse is not true: If you take the bridge, you might not enter the castle -- the knight might still stab you in the head and you'll never make it to the castle!\n\n::: {.callout-important title=\"Only If\" appearance=\"minimal\"}\nExercise:\n\nLet $P$ be the proposition \"$x+1 = 2$\" and let $Q$ be the proposition \"$x=1$\". Is the proposition \"$P$ only if $Q$\" the same as $P\\to Q$ or $Q\\to P$?\n:::\n\n::: {.callout-important title=\"Only If\" appearance=\"minimal\"}\nExercise:\n\nGo back to the two examples in the previous section ([link here](core_examples.html)) and identify all instances of if-then sentences.\n:::\n\n## Biconditional\n\nBecause it comes up so often, we will use the symbol $\\leftrightarrow$ as an abbreviation for $(P\\to Q) \\land (Q\\to P)$. It is often represented in English by a sentence of the form \"$P$ if and only if $Q$\". This form doesn't come up extremely often in natural scenarios, but it comes up in mathematics everywhere.\n\n::: {.callout-important title=\"Biconditional Truth Table\" appearance=\"minimal\"}\nExercise:\n\nProduce the truth-table for $P\\leftrightarrow Q$, and show that $\\leftrightarrow$ is both commutative and associative.\n:::\n\n","srcMarkdownNoYaml":"\n\nWe looked at two examples of arguments in the previous section, but we don't want to be too focused on specific cases. Eventually we want to analyze logic itself, so that it can be applied to any propositions that may come up.\n\n# Propositional Variables\n\nWe will write an abstract proposition with a variable, like $P$.  What this means is that $P$ could be any proposition, and we don't know which it is.  So for instance $P$ could represent $x=1$ or \"Russia is large\", or any other assertion that could be true or false.  \n\nBecause we don't know whether an abstract proposition is true or false, we represent this in a table.  In the table below, naturally we use $T$ to denote \"true\" and $F$ to denote \"false\".\n\n$$\n\\begin{array}{|c|} \\hline \nP \\\\ \\hline\nT \\\\ \\hline\nF \\\\ \\hline\n\\end{array}\n$$\n\nFor now, the table may seem like making too big a deal over a small thing. As the abstract propositions get more complex, though, the tables will help us to manage that complexity. So if this doesn't make sense right now, don't worry too much about it. As you see the table really do its job in the next few subsections, it will make more sense.\n\n# Truth-functional Connectives\n\nA propositional variable by itself is boring. The way that we will analyze arguments is by breaking it into its component sentences. These sentences are themselves formed by joining together simpler sentences. Take for instance\n\n> Either $x=1$ or $x\\ne 1$.\n\nAlign the sentence $x=1$ with the propositional variable $P$, and $x\\ne 1$ with the sentence $Q$. Then the sentence in the quote-block above is \"$P$ or $Q$\". This is an example of a sentence which is formed by joining together simpler sentences.\n\n## Negation\n\nOne way to form a new proposition from the variable $P$ is to negate it. If the proposition $P$ is aligned with $x=1$ then its negation is \"$x$ is not equal to 1\", or in more standard mathematical notation, $x\\ne 1$. This flips the truth-value of the proposition being negated.\n\nTo represent the negation of $P$ we write $\\neg P$.\n\nBelow is the truth-table for negation. \n\n$$\n\\begin{array}{|c||c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P & \\neg  P \\\\ \\hline \\\\\\hline\nT & \\color{red}F  \\\\ \\hline\nF & \\color{red}T  \\\\ \\hline\n\\end{array}\n$$\n\nNow that the table is getting sophisticated, I'm adding some extra features. First of all, I've shaed the first row and column with a gray background.  This is to indicate that the first row is a header row.  Also the first column as a kind of header column, because we will just use it to \"index\" the entries in the body of the truth table.  \n\nThe first \"real\" content of the table is emphasized below.  \n\n$$\n\\begin{array}{|c||c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P & \\neg  P \\\\ \\hline \\\\\\hline\nT & \\bf \\color{red}F  \\\\ \\hline\nF & \\color{red}T  \\\\ \\hline\n\\end{array}\n$$\n\nThis is computed by first finding the value $P$, which is $T$ on this row.  Then we apply the $\\neg$ operation to it, flipping it to $F$ and hence this is the value.  The second row of truth-values is computed similarly.  \n\n::: {.callout-important title=\"Double Negation\" appearance=\"minimal\"}\nExercise:\n\nMake the truth-table for $\\neg (\\neg P)$.\n\nWe say that two propositions are **equivalent** if they \"have the same truth-table\".[^2] Are $P$ and $\\neg(\\neg P)$ equivalent?\n:::\n\n[^2]: Having the same truth-table means: They have the same truth-value at every row of the table.\n\n------------------------------------------------------------------------\n\nNegation is also represented in almost every programming language. Below we can see how Python represents truth values, and then see how Python gives the ability to negate them.\n\n```{python}\nprint(not True)\nprint(not False)\n```\n\n::: {.callout-important title=\"DN in Python\" appearance=\"minimal\"}\nExercise:\n\nDemonstrate double-negation (i.e. the equivalence of $P$ and $\\neg(\\neg P)$) in a Python program.\n:::\n\n## Disjunction\n\nIf $P$ and $Q$ are any two propositional variables, then to express \"$P$ or $Q$\" we write $P\\lor Q$. Note that by saying that either sentence is true, it is enough if just one of them is true. Take for example the sentence \"Either the prize is behind the first door or the second door.\" If the prize is behind the first door, then that sentence was true. But if the prize was behind the third door (i.e. not the first and not the second), the sentence was false.\n\nThis is called the **disjunction** of $P$ and $Q$, and it has the following truth-table.\n\n$$\n\\begin{array}{|c|c|ccc|}\\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&Q\\columncolor{lightgray}&P&\\lor &Q\\\\\\hline&&&&\\\\\\hline\nT&T&&\\color{red}T&\\\\\\hline\nT&F&&\\color{red}T&\\\\\\hline\nF&T&&\\color{red}T&\\\\\\hline\nF&F&&\\color{red}F&\\\\\\hline\n\\end{array}\n$$\n\nNote that this time the table has four rows (not counting the header row which declares the variables and proposition). This is because there are more possibilities with two variables than with just one. We could have both $P$ and $Q$ true, which is the first row -- or we could have one true and the other false, which is the next two rows -- or both could be false, which is the final row.\n\nIn Python we can model this with the disjunction operator.\n\n```{python}\nprint(True or True)\nprint(True or False)\nprint(False or True)\nprint(False or False)\n```\n\nIn fact, the above can be done more simply in a couple of \"embedded for-loops\", as shown below.\n\n```{python}\ntruth_values = [True, False] # A list of all truth values\nfor P in truth_values: # Iterate through all truth values\n    for Q in truth_values: # Q does likewise\n        print(P or Q) # Compute \"their 'or'\" and print it.\n```\n\nThe way that the above code works is: `P` is a variable, and it will eventually \"take\" every value from the list `[True,False]`. Initially it takes the value `True`.\n\nAfter `P` takes `True` then the code inside, `for Q in [True,False]: print(P or Q)` executes. But the way that this executes is, similarly, that `Q` starts by taking the value `True`. Then the program executes `print(P or Q)` which is effectively equivalent to `print(True or True)`.\n\nMaking a long story short, on the next loop iteration, `P` is still true but `Q` takes the value `False`. Then `print(P or Q)` executes, which is equivalent to `print(True or False)`. Then `P` ticks over to `False` and `Q` starts over at `True`, and `print(P or Q)` is equivalent to `print(False or True)`. Then `P` is `False` and `Q` takes `True`, and `print(P or Q)` is equivalent to `print(False or False)`.\n\n::: {.callout-important title=\"Not Loop\" appearance=\"minimal\"}\nExercise:\n\nThis code:\n\n```{python}\nprint(not True)\nprint(not False)\n```\n\ncould instead be implemented with a for-loop.  Fill in the parts of the following code where it contains `%TODO` so that it does the same thing as the code above.\n\n```{python}\nfor P in [True, False]:\n    \"\\%TODO\"\n```\n:::\n\n------------------------------------------------------------------------\n\nIf we use three variables, we can analyze the sentence $P\\lor (Q\\lor R)$. This now requires even more rows of truth-values. How many more?\n\nWell it should *double* the number of rows, from how many were needed for two variables. That is because we need to consider two possibilities: Either $P$ is true or it is false. If $P$ is true, then we need to run through all of the remaining four possibilities for $Q$ and $R$. So this half of the truth-table should look like:\n\n$$\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nT&T&T\\\\\\hline\nT&T&F\\\\\\hline\nT&F&T\\\\\\hline\nT&F&F\\\\\\hline\n\\end{array}\n$$\n\nThen it's clear what we do for the other half, where $P$ is $F$.\n\n$$\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nF&T&T\\\\\\hline\nF&T&F\\\\\\hline\nF&F&T\\\\\\hline\nF&F&F\\\\\\hline\n\\end{array}\n$$\n\nPutting these together we get the eight-row truth-table\n\n$$\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nT&T&T\\\\\\hline\nT&T&F\\\\\\hline\nT&F&T\\\\\\hline\nT&F&F\\\\\\hline\nF&T&T\\\\\\hline\nF&T&F\\\\\\hline\nF&F&T\\\\\\hline\nF&F&F\\\\\\hline\n\\end{array}\n$$\n\n::: {.callout-important title=\"General Row Numbers\" appearance=\"minimal\"}\nExercise:\n\nIf there were 4 variables, how many rows would be needed?  (Hint: One variable required two rows.  Two variables, four rows; three variables, eight row; ...)\n\nIf there were $n$ variables, how many rows would be needed?\n:::\n\nNow that we know the column and row \"headers\" (I am regarding each of the first three columns as a kind of header column.) we can fill in the table for $P\\lor Q\\lor R$. However, doing it all at once can be difficult to parse, so let's do this in stages. First let's merely populate the columns under the variables -- this is a tedious transcription.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\nP&Q&R&&P&\\lor &(Q&\\lor &R)\\\\\\hline\\\\\\hline\nT&T&T && T &  & T &  & T\\\\\\hline\nT&T&F && T &  & T &  & F\\\\\\hline\nT&F&T && T &  & F &  & T\\\\\\hline\nT&F&F && T &  & F &  & F\\\\\\hline\nF&T&T && F &  & T &  & T\\\\\\hline\nF&T&F && F &  & T &  & F\\\\\\hline\nF&F&T && F &  & F &  & T\\\\\\hline\nF&F&F && F &  & F &  & F\\\\\\hline\n\\end{array}\n$$\n\nNow we try to fill in the values under any operators. However, if we look at the first $\\lor$ operator, we cannot fill it in! This is because it must \"read\" the value to its left and right. The values to the left are there, but the values to the right come from everything inside $(Q\\lor R)$. These values should be read from what appears under the $\\lor$ and they are blank. Therefore we must fill these in first.\n\nTo fill in the values under $(Q\\lor R)$, we get the following table. Notice that the first row is computed as $T\\lor T=T$. The second is $T\\lor F=T$ and the third is $F\\lor T = T$ and the fourth is $F\\lor F=F$, and so on. Because this column of computation is derived from others, I will color it.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\nP&Q&R&&P&\\lor &(Q&\\lor &R)\\\\\\hline\\\\\\hline\nT&T&T && T &  & T & \\color{blue}T & T\\\\\\hline\nT&T&F && T &  & T & \\color{blue}T & F\\\\\\hline\nT&F&T && T &  & F & \\color{blue}T & T\\\\\\hline\nT&F&F && T &  & F & \\color{blue}F & F\\\\\\hline\nF&T&T && F &  & T & \\color{blue}T & T\\\\\\hline\nF&T&F && F &  & T & \\color{blue}T & F\\\\\\hline\nF&F&T && F &  & F & \\color{blue}T & T\\\\\\hline\nF&F&F && F &  & F & \\color{blue}F & F\\\\\\hline\n\\end{array}\n$$\n\nAnd now that this column has been populated, the column under the first $\\lor$ now \"sees\" all the values that it needs to compute. Therefore we do this in the table below. Note that the first row is computed as $T\\lor{\\color{blue} T}=\\color{red}T$, and the fourth row is computed as $T\\lor {\\color{blue} F}=\\color{red} T$, for two illustrations.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\nP&Q&R&&P&\\lor &(Q&\\lor &R)\\\\\\hline\\\\\\hline\nT&T&T && T & \\color{red}T & T & \\color{blue}T & T\\\\\\hline\nT&T&F && T & \\color{red}T & T & \\color{blue}T & F\\\\\\hline\nT&F&T && T & \\color{red}T & F & \\color{blue}T & T\\\\\\hline\nT&F&F && T & \\color{red}T & F & \\color{blue}F & F\\\\\\hline\nF&T&T && F & \\color{red}T & T & \\color{blue}T & T\\\\\\hline\nF&T&F && F & \\color{red}T & T & \\color{blue}T & F\\\\\\hline\nF&F&T && F & \\color{red}T & F & \\color{blue}T & T\\\\\\hline\nF&F&F && F & \\color{red}F & F & \\color{blue}F & F\\\\\\hline\n\\end{array}\n$$\n\n::: {.callout-important title=\"Python Triple Disjunction\" appearance=\"minimal\"}\nExercise:\n\nDemonstrate a couple of rows of the truth-table above in some Python code. For instance, run stuff like `True or (False or False)`.\n\nThen write a triple-for-loop to reproduce the entire truth-table.\n:::\n\n::: {.callout-important title=\"Finite Disjunction\" appearance=\"minimal\"}\nExercise:\n\nNotice that the only row at which $P\\lor(Q\\lor R)$ is $F$ is the final row. That's also true for $P\\lor Q$. In fact, if you make the truth-table for $P\\lor (Q\\lor (R\\lor S))$ it will be the same.\n\nWrite a Python program to demonstrate this.\n\n------------------------------------------------------------------------\n\nIn general, a disjunction of $n$ variables will be true if how many of the variables take the value $T$?\n:::\n\n::: {.callout-important title=\"Disjunction Associativity\" appearance=\"minimal\"}\nExercise:\n\nI claim that $P\\lor (Q\\lor R)$ is equivalent to $(P\\lor Q)\\lor R$. Write a Python program to prove that this is true.\n\nThis fact is called the **associativity** of disjunction.\n\n------------------------------------------------------------------------\n\nI also claim that disjunction is **commutative** which means $P\\lor Q$ is equivalent to $Q\\lor P$. Write a Python program to prove that this is true.\n:::\n\n::: {.callout-important title=\"Parsing Ambiguity\" appearance=\"minimal\"}\nExercise:\n\nMake a truth table for both $\\neg (P\\lor Q)$ and $(\\neg P)\\lor Q$, and check your answers with the following Python code.\n\n```{python echo=True}\nfor P in [True, False]:\n    for Q in [True, False]:\n        print(not (P or Q))\n\nprint() # Just print a blank line to help see the separation of the two tables.\n\nfor P in [True, False]:\n    for Q in [True, False]:\n        print((not P) or Q)\n```\n\nThen use these two truth-tables to argue that these two propositions are **not** equivalent.\n\nUse the above result to argue that $\\neg P\\lor Q$ is meaningless.\n\nHowever, although $\\neg P\\lor Q$ is technically meaningless, we will in fact assume that if we ever write $\\neg P\\lor Q$ it is actually short-hand for $(\\neg P)\\lor Q$. The more general rule is that\n\n> Negation takes precedence.\n\nThat is to say, in any abstract logical expression in which negation occurs, we will assume that it applies *first*.\n\nAnd technically $P\\lor Q\\lor R$ is meaningless because we technically require parentheses to distinguish between $P\\lor (Q\\lor R)$ and $(P\\lor Q)\\lor R$. However, since we have seen that these are equivalent, then we may understand $P\\lor Q\\lor R$ as shorthand for either of these -- and it doesn't matter which one. Therefore this, too, will be our convention. That is to say, we will gladly write $P\\lor Q\\lor R$ and allow the reader to interpret this as either $P\\lor (Q\\lor R)$ or $(P\\lor Q)\\lor R$, whichever is their favorite.\n:::\n\n\n\n## Conjunction\n\nHaving done all that work for disjunction, conjunction is mostly trivial. It represents the proposition \"$P$ and $Q$\", we write this symbolically as $P\\land Q$, and it has the following truth-table.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|}\\hline\nP&Q&&P&\\land &Q\\\\\\hline\\\\\\hline\nT&T&&T&\\color{red}T&T\\\\\\hline\nT&F&&T&\\color{red}F&F\\\\\\hline\nF&T&&F&\\color{red}F&T\\\\\\hline\nF&F&&F&\\color{red}F&F\\\\\\hline\n\\end{array}\n$$\n\n::: {.callout-important title=\"Conjunction Catchall\" appearance=\"minimal\"}\nExercise:\n\nRe-do all the exercises for disjunction but this time for conjunction, noting any interesting dissimilarities.\n:::\n\n::: {.callout-important title=\"Distribution\" appearance=\"minimal\"}\nExercise:\n\nShow (either in a table or a program) that $P\\land (Q\\lor R)$ is **not** equivalent to $(P\\land Q)\\lor R$ and conclude that \"conjunction and disjunction do not associate\".[^5]\n\nHowever, show that $P\\land (Q\\lor R)$ is equivalent to $(P\\land Q) \\lor (P\\land R)$. Also, come up with a corresponding equivalence for $P\\lor (Q\\land R)$ and prove that it's equivalent.\n\nThe above is called the **distribution** of $\\land$ over $\\lor$ (and conversely). This is similar to how multiplication distributes over addition.\n\n$$ \nx(y+z) = xy+xz \n$$\n\nHowever, note that addition does **not** distribute over multiplication.\n\n$$\nx+yz \\ne (x+y)(x+z)\n$$\n\nTherefore these logical operators are \"more distributive\" than the mathematical operators. Each distributes over the other, whereas in mathematics, it is only that multiplication distributes over addition.\n:::\n\n[^5]: It may take an act of interpretation to know exactly what is being asked here. But to say that \"conjunction and disjunction do not associate\", means that if an expression has both symbols, then you cannot merely switch around the parentheses.\n\n## The Conditional\n\nThe conditional is, in a sense, no different from the other logical symbols. It is meant to represent propositions of the form \"If $P$ then $Q$.\" It has symbol $\\to$ and truth-table\n\n$$\n\\begin{array}{|c|c|c|c|c|c|}\\hline\nP&Q&&P&\\to &Q\\\\\\hline\\\\\\hline\nT&T&&T&\\color{red}T&T\\\\\\hline\nT&F&&T&\\color{red}F&F\\\\\\hline\nF&T&&F&\\color{red}T&T\\\\\\hline\nF&F&&F&\\color{red}T&F\\\\\\hline\n\\end{array}\n$$\n\nHowever, this truth-table is probably perplexing. Let's try to see the correspondence between a sentence of the form \"If $P$ then $Q$.\" and this truth-table. Consider these four examples:\n\n::: {.callout-note title=\"If Then Example\" appearance=\"minimal\"}\nExample:\n\nIf the sun is out, then the weather is warm.\n:::\n\nNow consider each of the four possibilities. The first is that the sun is out and the weather is warm. Well, it makes sense that the sentence was true in this case. This explains the first row, since we aligned $P$ with a true sentence, $Q$ with a true sentence, and the result is a true sentence.\n\nNext consider the possibility that the sun is out, but because you live in the South Pole, the weather is cold. In this case, the sentence was false. This explains the second row since $P$ is true and $Q$ false.\n\nSo far I think everything makes pretty immediate sense, but the next two possibilities are the ones that most people struggle with the most. What is especially difficult about them is that $P$ is false. A sentence of the form \"If $P$ then $Q$.\" is quite literally predicated upon the assumption of $P$, so it becomes quite difficult to think about what one should say if $P$ is false.\n\nIn the table, it is clear that we have decided that, when $P$ is false, the conditional sentence is true (regardless of the truth-value of $Q$). You can imagine that it behaves like a promise: \"I promise that, IF the sun is out, then the weather is warm.\" When the condition of the promise is removed, because say the sun is not out, then the promise is so-to-speak nullified -- and we say that the speaker was speaking the truth.\n\nIn the example of the sun and the weather, imagine the \"false-true\" case in which the sun is not out but the weather is still warm. In that case, we regard the speaker as not wrong, because the condition of the sentence was not met. And similarly, in the false-false case whether the sun is not out and the weather is not warm, again the speaker is still speaking the truth.[^6]\n\n[^6]: The entire topic of the conditional is, in fact, a giant philosophical mess. There has been an enormous literature in linguistics and philosophy on the precise meaning and \"truth-conditions\" for conditional sentences. The resounding agreement among specialists, is that natural languages do not use a truth-functional conditional. That is to say, real languages have a meaning to their conditional sentences, which cannot be captured in a truth-table. Therefore one should regard the conditional that we use in mathematics as a kind of \"formal language\" rather than a natural language.\n\n::: {.callout-important title=\"Conditional Properties\" appearance=\"minimal\"}\nShow that the conditional is neither associative nor commutative.\n:::\n\nBesides having the most confusing truth-table, the conditional also is the hardest to translate to and from natural language. Of course if we say \"If a polygon has three angles then it is a triangle,\" then we would align $P$ with the sentence \"the polygon has three angles\" and $Q$ with \"the polygon is a triangle\". The the entire proposition is aligned with $P\\to Q$.\n\nHowever, the first clause is not always the one that goes to the left of the $\\to$. The example sentence is equivalent to \"The polygon is a triangle if it has three angles.\" This makes it seem as though the clause after the word \"if\" will always appear to the left of the $\\to$.\n\nHowever, even this is not true! The sentence \"The polygon is a triangle only if it has three angles\" is equivalent to \"If the polygon is a triangle then it has three angles\"! This one is often especially confusing to a new student, learning about the conditional.\n\nTo help make the \"only if\" construction clearer, imagine a castle which is only accessible by a bridge, which is guarded by a knight.\n\n![](/_site/prop_log\\images\\knight.png){fig-align=\"left\" width=\"204\"}\n\nThen the sentence \"You can enter the castle only if you take the bridge\" can be stated as the if-then sentence\n\n> If you are in the castle then you took the bridge.\n\nNote that the reverse is not true: If you take the bridge, you might not enter the castle -- the knight might still stab you in the head and you'll never make it to the castle!\n\n::: {.callout-important title=\"Only If\" appearance=\"minimal\"}\nExercise:\n\nLet $P$ be the proposition \"$x+1 = 2$\" and let $Q$ be the proposition \"$x=1$\". Is the proposition \"$P$ only if $Q$\" the same as $P\\to Q$ or $Q\\to P$?\n:::\n\n::: {.callout-important title=\"Only If\" appearance=\"minimal\"}\nExercise:\n\nGo back to the two examples in the previous section ([link here](core_examples.html)) and identify all instances of if-then sentences.\n:::\n\n## Biconditional\n\nBecause it comes up so often, we will use the symbol $\\leftrightarrow$ as an abbreviation for $(P\\to Q) \\land (Q\\to P)$. It is often represented in English by a sentence of the form \"$P$ if and only if $Q$\". This form doesn't come up extremely often in natural scenarios, but it comes up in mathematics everywhere.\n\n::: {.callout-important title=\"Biconditional Truth Table\" appearance=\"minimal\"}\nExercise:\n\nProduce the truth-table for $P\\leftrightarrow Q$, and show that $\\leftrightarrow$ is both commutative and associative.\n:::\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"arrow","css":["../styles.css"],"toc":true,"output-file":"abstract_propositions.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.241","editor_options":{"chunk_output_type":"inline"},"jupyter":"python3","monobackgroundcolor":"#f9f9f9","code-block-border-left":"#31BAE9","theme":"cosmo","toc-expand":3,"title":"Abstract Propositions"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}