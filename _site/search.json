[
  {
    "objectID": "prop_log/sandbox.html",
    "href": "prop_log/sandbox.html",
    "title": "How to Become a Mathematician",
    "section": "",
    "text": "Code\n### OLD CODE ###\nimport pyparsing as pp\n\nclass Proposition:\n    pass\n\nclass PropVariable(Proposition):\n    def __init__(self, v):\n        assert (type(v) == type(\"\") and len(v) == 1) \n        self.v = v\n    def __str__(self):\n        return(self.v)\n    def eval(self, prop_eval):\n        return prop_eval(self.v)\n    def __eq__(self, p):\n        if type(p) == PropVariable: return p.v == self.v\n        return False\n\nclass Negation(Proposition):\n    def __init__(self, beta):\n        assert issubclass(type(beta),Proposition)\n        self.neg = beta\n    def __str__(self):\n        return(\"(not \" + str(self.neg) + \")\")\n    def eval(self, prop_eval):\n        return(not self.neg.eval(prop_eval))\n    def __eq__(self, p):\n        if type(p) == Negation: return p.neg == self.neg\n        return False\n\nclass Disjunction(Proposition):\n    def __init__(self, beta, gamma):\n        assert issubclass(type(beta),Proposition) \\\n            and issubclass(type(gamma),Proposition)\n        self.left, self.right = beta, gamma\n    def __str__(self):\n        return(\"(\" + str(self.left )+\" or \" + str(self.right) + \")\")\n    def eval(self, prop_eval):\n        l, r = self.left.eval(prop_eval), self.right.eval(prop_eval)\n        return( l or r )\n    def __eq__(self, p): \n        if type(p) == Disjunction: \n            return p.left == self.left and p.right == self.right\n        return False\n\nclass Conditional(Proposition):\n    def __init__(self, beta, gamma):\n        assert issubclass(type(beta),Proposition) \\\n            and issubclass(type(gamma),Proposition)\n        self.ante, self.conseq = beta, gamma\n    def __str__(self):\n        return(\"(if \" + str(self.ante) + \" then \" + str(self.conseq) + \")\")\n    def eval(self, prop_eval):\n        ante, conseq = self.ante.eval(prop_eval), self.conseq.eval(prop_eval)\n        return (not ante) or conseq\n    def __eq__(self, p) -&gt; bool:\n        if type(p) == Conditional:\n            return p.ante==self.ante and p.conseq==self.conseq\n        return False\n\ndef parseTree(p):\n    if type(p) == type(\"\"):\n        return PropVariable(p)\n    if len(p) == 1:\n        return parseTree(p[0])\n    if len(p) == 2:\n        assert( p[0] == \"not\" )\n        return Negation(parseTree(p[1]))\n    \n    if len(p) == 3:\n        if p[1] == \"or\": return Disjunction(parseTree(p[0]), parseTree(p[2]))\n        raise Exception(\"length 3 list but unrecognized middle token\")\n    if len(p) == 4:\n        if p[0] == \"if\" and p[2] == \"then\":\n            return Conditional(parseTree(p[1]),parseTree(p[3]))\n    raise Exception(\"length of list unrecognized\")\n\nterms = pp.Word(pp.alphas) | \"not\" | \"and\" | \"or\" | \"if\" | \"then\" | \"iff\" \nnesting = pp.nestedExpr( '(', ')', content=terms )\n\ndef shape(s): \n    if s.strip() == \"\": return \"\"\n    p = nesting.parseString(\"(\"+s+\")\")[0]\n    \n    return parseTree(p)\n\n\n\n\nCode\n### NEW CODE ###\ndef disjunction_elimination(sup1,sup2,conc):\n    # For disjunction elimination, one proposition must be a disjunction\n    # and the other must be a negation.\n    disj, neg = sup1, sup2\n    if type(disj) != Disjunction: \n        disj, neg = sup2, sup1\n    if type(disj) != Disjunction or type(neg) != Negation: \n        return False\n  \n    # In order to reach this line of the function, we must have a disjunction\n    # in `disj` and negation in `neg`.  \n    \n    # Now in order to be an instance of *Disjunction Elimination*, the \n    # propsition under the negation must match one of the two disjuncts.\n    # Whichever disjunct matches, the other disjunct should be the final \n    # proposition in the inference (the conclusion).\n    under = neg.neg\n    other = disj.right\n    if under != disj.left:\n        other = disj.left\n        if under != disj.right: \n            return False\n    return other == conc\n\n# disj = shape(\"P or Q\")\n# neg = shape(\"not P\")\n# conc = shape(\"Q\")\n\n# print(disjunction_elimination(disj,neg,conc))\n\n\n\n\nCode\n### BORING CODE ###\ndef rows_list(argument):\n    level = 0\n    bucket = []\n    row = \"\"\n    for c in argument:\n        if c == \")\": \n            level -= 1\n            if level == 0:\n                bucket.append(row)\n                row = \"\"\n        if level &gt; 0: row += c\n        if c == \"(\": level += 1\n    return bucket\n\n\n\n\nCode\n\ndef incr_rownum(num, reason_name):\n    if reason_name == \"Assumption\":\n        num += [1]\n    elif reason_name == \"End Subproof\":\n        num = num[:-1]\n        num[-1] += 1\n    else:\n        num[-1] += 1\n\n\n\n\nCode\n\ndef row_string_to_list(rs):\n    bucket = rs.split(\".\")[:-1]\n    for i in range(len(bucket)):\n        bucket[i] = int(bucket[i])\n    return bucket\n\n\n\n\nCode\n\ndef x_sees_y(x, y):\n    n1, n2 = len(y), len(x)\n    if n2 &lt; n1: return False\n    for i in range(n1-1):\n        if y[i] != x[i]: \n            return False\n    return y[n1-1] &lt;= x[n1-1]\n\n\n\n\nCode\n\n### INTERESTING CODE ###\ndef validate(argument):\n    # Preprocess the argument into a list of lists.  \n    rl = rows_list(argument)\n    for i in range(len(rl)):\n        rl[i] = rl[i].split(\"; \")\n        rl[i][0] = row_string_to_list(rl[i][0])\n        rl[i][1] = shape(rl[i][1])\n    # When the preprocessing is done, the input \n    # \"(1.; P or Q; Premise), (2.; R or (P or Q); Disjunction Introduction, 1.)\" \n    # looks like \n    # [[[1], Disjunction(...), \"Premise\"], \\\n    #  [[2], Disjunction(...), \"Disjunction Introduction, 1.\"]]\n\n    # We will validate the row numbering of the argument, by \n    # building our own row numbering as we iterate through the \n    # list, and check that it matches the given numbering.\n    rownum = [1]\n    for i, row in enumerate(rl):\n        \n        if rownum != row[0]:\n            raise Exception(\"Invalid row numbering.\")\n        \n        reason = row[2].split(\", \")\n        reason_name = reason[0]\n        incr_rownum(rownum, reason_name)\n\n        if reason_name in [\"Premise\", \"Assumption\"]: continue\n\n        # Validating *Disjunction Elimination* requires \n        if reason_name == \"Disjunction Elimination\":\n            # finding the referenced row numbers\n            sup_ind1 = row_string_to_list(reason[1]) \n            sup_ind2 = row_string_to_list(reason[2])\n\n            # checking that they're not in a closed \n            # subproof\n            if not (x_sees_y(row[0],sup_ind1) and \\\n                    x_sees_y(row[0],sup_ind2)):\n                return False\n            \n            # getting the row at these numbers\n            for r in rl:\n                if r[0] == sup_ind1:\n                    sup1 = r[1]\n                if r[0] == sup_ind2:\n                    sup2 = r[1]\n            \n            # and checking that they match the pattern.\n            if not disjunction_elimination(sup1,sup2,row[1]):\n                return False\n        \n        if reason_name == \"Conditional Introduction\":\n            cond_prop = row[1]\n            next_row = rl[i+1]\n            if type(cond_prop) != Conditional:\n                return False\n            # Conditional introduction checks the next row to see\n            # that it's the beginning of an assumption with the \n            # same proposition as is the antecedent of the \n            # conditional.\n            cert = next_row[2] == \"Assumption\"\n            cert *= cond_prop.ante == next_row[1]\n            if not cert: return False\n            # Then it finds the closing \"End Subproof\", and checks\n            # that on the line before, the subproof ended at the \n            # consequent of the conditional.\n            cert = False\n            for j in range(i+1,len(rl)):\n                if len(rl[j][0]) == len(next_row[0]) \\\n                    and rl[j][2] == \"End Subproof\" \\\n                    and rl[j-1][1] == row[1].conseq:\n                    cert = True\n            if not cert: return cert\n        \n        return True\n\n        \n# disj_argument = \"(1.; P or Q; Premise), (2.; not Q; Premise), (3.; P; Disjunction Elimination, 1., 2.)\"\n# print(validate(disj_argument))\n\ncond_argument = \"(1.; if P then Q; Conditional Introduction), (1.1.; P; Assumption), (1.2.; Q; Premise), (1.3.; ; End Subproof))\"\nprint(validate(cond_argument))\n\n\nTrue\n\n\n\n\nCode\nfrom manim import *\nconfig.media_width = \"100%\"\n\n\nManim Community v0.17.3\n\n\n\n\n\n\nCode\n%%manim -qm -v WARNING R2\n\nclass R2(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        self.play(Create(plane))\n\n        vec = Arrow([0,0,0],[1,2,0], buff=0, color=\"RED\")\n        self.play(Create(vec))\n\n        vec2 = Arrow([0,0,0],[-2,1,0], buff=0, color=\"RED\")\n        self.play(Transform(vec,vec2))\n        self.remove(vec)\n\n        vec3 = Arrow([0,0,0],[-1,-3,0], buff=0, color=\"RED\")\n        vec4 = Arrow([0,0,0],[2,0,0], buff=0, color=\"RED\")\n        vec5 = Arrow([-1,-3,0],[0,-2,0], buff=0, color=\"YELLOW\")\n\n        self.play(Transform(vec2,vec4))\n        self.remove(vec2)\n        self.play(Transform(vec4,vec3))\n        self.play(Create(vec5))\n\n        label1 = MathTex(r\"\\begin{bmatrix} -1\\\\-2\\end{bmatrix}\", color=RED).move_to([-1,0,0])\n        self.play(Write(label1))\n\n        label2 = MathTex(r\"\\begin{bmatrix} 1\\\\1\\end{bmatrix}\", color=YELLOW).move_to([1,-1,0])\n        vec6 = Arrow([0,0,0],[1,1,0], buff=0)\n        self.play(Write(label2))\n\n        label3 = MathTex(r\"\\begin{bmatrix}1\\\\1\\end{bmatrix}\").move_to([1,2,0])\n        self.play(Create(vec6))\n        self.play(Write(label3))\n\n        self.wait(3)\n        \n\n\n                                                                                                                    \n\n\n\n      Your browser does not support the video element.\n    \n\n\n\n\nCode\n%%manim -qm -v WARNING R3\n\nclass R3(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n        space = ThreeDAxes()\n        self.play(Create(space))\n\n        vec = Arrow([0,0,0],[1,2,-3], buff=0, color=\"RED\")\n        vec2 = Arrow([0,0,0],[-2,1,3], buff=0, color=\"RED\")\n        vec3 = Arrow([0,0,0],[-1,-3,3], buff=0, color=\"RED\")\n        vec4 = Arrow([0,0,0],[2,0,-4], buff=0, color=\"RED\")\n        vec5 = Arrow([-1,-3,0],[0,-2,-2], buff=0, color=\"YELLOW\")\n        vec6 = Arrow([0,0,0],[1,1,0], buff=0)\n\n        self.play(Create(vec))\n\n        self.play(Transform(vec,vec2))\n        self.remove(vec)\n\n        self.play(Transform(vec2,vec4))\n        self.remove(vec2)\n\n        self.play(Transform(vec4,vec3))\n        self.play(Create(vec5)) \n\n        label1 = MathTex(r\"\\begin{bmatrix} -1\\\\-3\\\\3\\end{bmatrix}\", color=RED).move_to([-2,-2,2])\n        self.play(Write(label1))\n\n        label2 = MathTex(r\"\\begin{bmatrix} 1\\\\1\\\\-2\\end{bmatrix}\", color=YELLOW).move_to([.5,-1.5,-2.5])\n        self.play(Write(label2))\n\n        label3 = MathTex(r\"\\begin{bmatrix}1\\\\1\\\\0\\end{bmatrix}\").move_to([1,2,0])\n        self.play(Create(vec6))\n        self.play(Write(label3))\n\n        self.move_camera(phi=2*PI/5, theta=-85 * DEGREES, zoom=.5, run_time=1.5)\n        self.move_camera(phi=1.5*PI/5, theta=-85 * DEGREES, zoom=.5, run_time=1.5)\n\n        self.wait(3)\n        \n\n\n                                                                                                                             \n\n\n\n      Your browser does not support the video element."
  },
  {
    "objectID": "prop_log/op_props.html",
    "href": "prop_log/op_props.html",
    "title": "Semantic Properties",
    "section": "",
    "text": "In this section we will discuss the logical operators in greater depth. Our focus will be on what are called “semantic properties”, which is to say, properties of these objects which determine their truth-values."
  },
  {
    "objectID": "prop_log/op_props.html#famous-tautologies",
    "href": "prop_log/op_props.html#famous-tautologies",
    "title": "Semantic Properties",
    "section": "Famous Tautologies",
    "text": "Famous Tautologies\nThe following is a summary of famous equivalences. They are each stated as a biconditional, so what I am showing is a collection of tautological biconditional propositions. In light of the exercise above, showing that propositions are equivalent if and only if their corresponding biconditional is a tautology, it should be clear which propositions are equivalent in the following summary.\n\n\n\n\n\n\nDouble Negation\n\n\n\n\\[\n\\neg(\\neg \\alpha) \\leftrightarrow \\alpha  \n\\]\n\n\n\n\n\n\n\n\nTop to Bot\n\n\n\n\\[\n\\neg \\top \\leftrightarrow \\bot\n\\]\n\n\n\n\n\n\n\n\nBot to Top\n\n\n\n\\[\n\\neg \\bot \\leftrightarrow \\top\n\\]\n\n\n\n\n\n\n\n\nOr Idempotence\n\n\n\n\\[\n(\\alpha\\lor\\alpha) \\leftrightarrow \\alpha\n\\]\n\n\n\n\n\n\n\n\nOr Commutativity\n\n\n\n\\[\n(\\alpha\\lor \\beta) \\leftrightarrow (\\beta\\lor \\alpha)\n\\]\n\n\n\n\n\n\n\n\nOr Associativity\n\n\n\n\\[\n(\\alpha\\lor(\\beta\\lor\\gamma)) \\leftrightarrow ((\\alpha\\lor\\beta)\\lor\\gamma)\n\\]\n\n\n\n\n\n\n\n\nOr Idempotence\n\n\n\n\\[\n\\alpha\\lor\\alpha \\leftrightarrow \\alpha\n\\]\n\n\n\n\n\n\n\n\nOr Tautology\n\n\n\n\\[\n\\alpha\\lor\\top \\leftrightarrow \\top\n\\]\n\n\n\n\n\n\n\n\nOr Contradiction\n\n\n\n\\[\n\\alpha\\lor\\bot \\leftrightarrow \\alpha\n\\]\n\n\n\n\n\n\n\n\nAnd Commutativity\n\n\n\n\\[\n(\\alpha\\land\\beta) \\leftrightarrow (\\beta\\land\\alpha)\n\\]\n\n\n\n\n\n\n\n\nAnd Associativity\n\n\n\n\\[\n(\\alpha\\land(\\beta\\land \\gamma))\\leftrightarrow ((\\alpha\\land\\beta)\\land \\gamma)\n\\]\n\n\n\n\n\n\n\n\nAnd Idempotence\n\n\n\n\\[\n\\alpha\\land\\alpha\\leftrightarrow \\alpha\n\\]\n\n\n\n\n\n\n\n\nAnd Tautology\n\n\n\n\\[\n\\alpha\\land\\top \\leftrightarrow \\alpha\n\\]\n\n\n\n\n\n\n\n\nAnd Contradiction\n\n\n\n\\[\n\\alpha\\land\\bot \\leftrightarrow \\bot\n\\]\n\n\n\n\n\n\n\n\nAnd Distribution over Or\n\n\n\n\\[\n(\\alpha \\land (\\beta\\lor\\gamma)) \\leftrightarrow ((\\alpha\\land\\beta)\\lor(\\alpha\\land\\gamma))\n\\]\n\n\n\n\n\n\n\n\nOr Distribution over And\n\n\n\n\\[\n(\\alpha\\lor(\\beta\\land\\gamma)) \\leftrightarrow ((\\alpha\\lor\\beta)\\land(\\alpha\\lor\\gamma))\n\\]\n\n\n\n\n\n\n\n\nOr De Morgan’s\n\n\n\n\\[\n\\neg(\\alpha\\lor\\beta)\\leftrightarrow (\\neg\\alpha\\land\\neg\\beta)\n\\]\n\n\n\n\n\n\n\n\nAnd De Morgan’s\n\n\n\n\\[\n\\neg(\\alpha\\land\\beta) \\leftrightarrow (\\neg\\alpha\\lor\\neg\\beta)\n\\]\n\n\n\n\n\n\n\n\nArrow to Or\n\n\n\n\\[\n(\\alpha\\to\\beta) \\leftrightarrow (\\neg\\alpha\\lor\\beta)\n\\]\n\n\n\n\n\n\n\n\nNeg Arrow\n\n\n\n\\[\n\\neg(\\alpha\\to\\beta) \\leftrightarrow (\\alpha\\land\\neg\\beta)\n\\]\n\n\n\n\n\n\n\n\nArrow Almost Idempotence\n\n\n\n\\[\n(\\alpha\\to\\neg\\alpha) \\leftrightarrow \\neg \\alpha\n\\]\n\n\n\n\n\n\n\n\nArrow Top\n\n\n\n\\[\n(\\top\\to\\alpha)\\leftrightarrow \\alpha\n\\]\n\n\n\n\n\n\n\n\nArrow Bot\n\n\n\n\\[\n(\\alpha\\to\\bot)\\leftrightarrow \\neg\\alpha\n\\]\n\n\n\n\n\n\n\n\nBinconditional Sameness\n\n\n\n\\[\n(\\alpha\\leftrightarrow\\beta) \\leftrightarrow ([\\alpha\\land\\beta]\\lor[\\neg\\alpha\\land\\neg\\beta])\n\\]\n\n\n\n\n\n\n\n\nProve Famous Equivalences\n\n\n\nExercise:\nProve any of the above."
  },
  {
    "objectID": "prop_log/eval.html",
    "href": "prop_log/eval.html",
    "title": "Propositional Evaluation",
    "section": "",
    "text": "We will often need to talk about the rows of a truth-table, and therefore in this section we will introduce some language to help us. In particular, we will identify each row of the truth-table with a variable evaluation."
  },
  {
    "objectID": "prop_log/eval.html#true-1-false-0",
    "href": "prop_log/eval.html#true-1-false-0",
    "title": "Propositional Evaluation",
    "section": "True = 1, False = 0",
    "text": "True = 1, False = 0\nTo give this an official, technical definition, it will help if we make the identification that \\(T\\) is actually just a symbol for the number 1, and \\(F\\) is actually just a symbol for the number 0. Indeed Python is designed in a way that reflects this reality “under the hood” of what \\(T\\) and \\(F\\) really are.\n\n\nCode\nprint(\"1 and 1 = \" + str(1 and 1))\nprint(\"1 and 0 = \" + str(1 and 0))\n\n\n1 and 1 = 1\n1 and 0 = 0\n\n\nWhat the code above shows is that, instead of using booleans True and False, one could just as well use the numbers 1 and 0 instead, and the behavior will be the same. In particular, the and operator is comfortable being given inputs which are booleans or the numbers 0 and 1.3\nBecause \\(T\\) and \\(F\\) can be regarded as simply the numbers 1 and 0, we will allow ourselves to therefore perform the usual arithmetic operations on them. That is to say, we will understand that \\(T+T = 2\\) is a true equation, since it merely says \\(1+1=2\\). Likewise \\(TF=F\\) where we regard the concatenation on the left as multiplication, and so on. Therefore this equation is true because \\(1\\cdot 0=0\\).\n\n\n\n\n\n\nBoolean Formulas\n\n\n\nIn order to compute a particular part of the truth-table for a conjunction, we use the rule that \\(T\\land T=T\\) and \\(T\\land F = F\\) and \\(F\\land T=F\\) and \\(F\\land F=F\\). But these just say the already familiar computations \\(1\\cdot 1=1\\) and \\(1\\cdot 0=0\\) and \\(0\\cdot 1=0\\) and \\(0\\cdot 0=0\\). Therefore we can express a formula for computing the conjunction of truth-values:\n\\[\nx\\land y = x\\cdot y\n\\]\nConfirm that there is also a formula for disjunction,\n\\[\nx\\lor y = x+y-xy\n\\]\n\nFind a formula for negation."
  },
  {
    "objectID": "prop_log/eval.html#the-evaluation-definition",
    "href": "prop_log/eval.html#the-evaluation-definition",
    "title": "Propositional Evaluation",
    "section": "The Evaluation Definition",
    "text": "The Evaluation Definition\nWe now have the setup necessary to define an evaluation function. Let \\(\\alpha\\) be a proposition and \\(\\mathcal E: V\\to\\{T,F\\}\\) any variable evaluation for \\(\\alpha\\). Define the extension of \\(\\mathcal E\\), the function \\(\\mathcal E^*\\), by:\n\nIf \\(P\\) is any propositional variable \\(P\\in V\\) then define \\(P^{\\mathcal E^*}=P^{\\mathcal E}\\).4\nIf \\(\\alpha\\) is a formula of the form \\(\\neg \\beta\\) then \\(\\alpha^{\\mathcal E^*} = 1-\\beta^{\\mathcal E^*}\\).5\nIf \\(\\alpha\\) is \\(\\beta\\lor\\gamma\\) then \\(\\alpha^{\\mathcal E^*} = F\\) if \\(\\beta^{\\mathcal E^*}=F\\) and \\(\\gamma^{\\mathcal E^*}=F\\). Otherwise \\(\\alpha^{\\mathcal E^*}= T\\).\n\nFor definitions when \\(\\alpha\\) is \\(\\beta\\land\\gamma,\\beta\\to\\gamma,\\) or \\(\\beta\\leftrightarrow \\gamma\\), see the exercises below.\n\nThis definition is often confusing to a student seeing this for the first time, so let’s see the idea in practice – hopefully if you see it used enough times, you’ll actually come to see the definition as quite familiar. The new kind of formalism being used here, just takes some getting used to.\n\n\n\n\n\n\nEvaluation Demonstrations\n\n\n\nLet us consider the propositions \\[\nP\n\\]\nand \\[\nP\\lor (Q\\lor (\\neg P))\n\\]\nWe will also consider the example variable evaluation \\(\\mathcal E\\) given by\n\\[\nP^{\\mathcal E}=F,Q^{\\mathcal E}=T,R^{\\mathcal E}=F\n\\]\nLet us use the definition above to find the evaluations \\(P^{\\mathcal E^*}\\) and \\((P\\lor (Q\\lor (\\neg P)))^{\\mathcal E^*}\\).\n\nFor the former, this is very simple and immediate. By clause (1) above, we merely use the variable evaluation.\n\\[\nP^{\\mathcal E^*} = P^{\\mathcal E} = F\n\\]\n\nNow let’s find \\((P\\lor(Q\\lor (\\neg P)))^{\\mathcal E^*}\\). Because this is a disjunction, we use clause (3), which indicates that we must find the evaluation of each disjunct.\nWe first must find the evaluation of the left disjunct, \\(P^{\\mathcal E^*}\\). But we already did that above and found \\(P^{\\mathcal E^*}=F\\).\nSo we now find the right-hand side \\((Q\\lor(\\neg P))^{\\mathcal E^*}\\). To find this again we need to find the values on either side of the \\(\\lor\\). From a calculation like before, we find that \\(Q^{\\mathcal E^*}=T\\).\nIn order to find \\((\\neg P)^{\\mathcal E^*}\\) we use clause 2. This tells us that\n\\[\n(\\neg P)^{\\mathcal E^*} = 1-P^{\\mathcal E^*} = 1-F = 1\n\\]\nwhere the first equality is due to clause 2, the second is due to our earlier calcuation, and the last is because \\(F\\) is the same as 0.\nNow we can find\n\\[\n(Q\\lor(\\neg P))^{\\mathcal E^*} = T\n\\]\nby clause 3, because we know that not both sides of the disjunction evaluated to false (in fact both evaluated to true).\nFinally we can now decide\n\\[\n(P\\lor(Q\\lor (\\neg P)))^{\\mathcal E^*} = T\n\\]\nbecause by clause 3, not both sides evaluated to false (the left evaluated to false but the right evaluated to true).\n\n\n\n\n\n\n\n\nNow You Evaluate\n\n\n\nUsing the same variable evaluation \\(\\mathcal E\\) above, find \\((P\\lor (\\neg R))^{\\mathcal E^*}\\).\n\n\n\n\n\n\n\n\nOther Evaluation Rules\n\n\n\nI left the rule for the evaluation of, for instance, \\(P\\land Q\\), unspecified. However, as you can see from the rule for \\(\\lor\\), this rule merely takes the evaluation of the left-hand disjunct, and the right-hand disjunct, and “puts them together” in the way that we’re familiar with from the truth-table.\nCome write down a rule for conjunction, like the one I explicitly gave for disjunction. Then use it to evaluate \\(P\\land Q\\) using the same variable evaluation as above.\nThen do likewise for \\(\\to\\) and \\(\\leftrightarrow\\). Make up your own examples to exercise these ideas."
  },
  {
    "objectID": "prop_log/core_examples.html",
    "href": "prop_log/core_examples.html",
    "title": "Two Examples",
    "section": "",
    "text": "In this section I want to introduce two arguments. If the lessons in this text are successful, the reader will understand the logic of these arguments in thorough detail.\n\nAlgebra by Cases\n\n\n\n\n\n\nSolve by Cases\n\n\n\nExample:\nLet \\(x\\) be a number satisfying the equation\n\\[\n(x-1)(x-2)=0\n\\]\nWe can easily see that \\(x=1\\) is a solution of this equation.\nOn the other hand, if \\(x\\ne 1\\) then \\(x-1\\ne 0\\). Therefore in this case we may divide both sides of the equation by \\(x-1\\). When we do, we obtain the equation \\(x-2=0\\) which implies \\(x=2\\).\nTherefore there are two solutions: \\(x=1\\) and \\(x=2\\).\n\\(\\Box\\)\n\n\n\n\n\n\n\n\nAlgebra Example Assumption Conclusion\n\n\n\nExercise:\nEvery argument starts from some assumptions. In the argument above, which sentences are assumptions?\nAlso every argument ends in a conclusion. In the argument above, what is the conclusion of the argument?\nAre there any key-words which seem to indicate an assumption? Are there key-words which indicate a conclusion?\n\n\n\nBelow is a proof that the sum of two positive numbers is always positive. It starts from the assumption that this is not true. That means that we start by assuming that some two positive numbers do not sum to a positive number. We will then derive a contradiction, and therefore show that the assumption was false.\n\n\n\n\n\n\nPositive Sum of Positives\n\n\n\nFor contradiction, assume that there are some two positive numbers which do not sum to a positive number. Call these numbers \\(a\\) and \\(b\\). Since they are positive, \\(0&lt;a\\) and \\(0&lt;b\\). And since they do not sum to a positive number, then \\(a+b\\le 0\\).\nFrom \\(0&lt;b\\) we can infer \\(-b&lt;0\\) by subtracting \\(b\\) from both sides. Then from \\(a+b\\le 0\\) we can infer \\(a\\le -b\\). But since we have \\(a\\le -b\\) and also \\(-b&lt;0\\) it follows that \\(a&lt;0\\). Therefore \\(a\\) is not positive.\nBut we established earlier that \\(a\\) is positive. Hence we have a contradiction: \\(a\\) is both positive and not positive.\nThe assumption that “there are some two positive numbers which do not sum to a positive,” led to a contradiction. Therefore the assumption must be false.\nThis shows that any two positive real numbers must sum to a positive number.\n\\(\\Box\\)\n\n\n\n\n\n\n\n\nNegative Sum of Negatives\n\n\n\nUse proof by contradiction to show that the sum of two negatives is always negative.\n\n\n\n\n\n\n\n\nNegative Irrational\n\n\n\nA number is called irrational if it is not rational. A number is rational if it can be expressed as \\(p/q\\) where \\(p\\) and \\(q\\) are two integers and \\(q\\ne 0\\).\nUse proof by contradiction to show that if \\(x\\) is irrational then so is \\(-x\\).\nHint: Fill in the following argument, where blanks are marked with %TODO.\n\nAssume, for contradiction, that %TODO. Then \\(-x\\) can be expressed as \\(p/q\\) where \\(p\\) and \\(q\\) are two integers, \\(q\\ne 0\\). That is to say, \\(-x=p/q\\). But then \\[\nx = \\%TODO\n\\] But then \\(-p\\) is an integer, and so is \\(q\\), and \\(q\\ne 0\\) still. Therefore \\(x\\) is %TODO.\nBut this is a contradiction, since we now have that \\(x\\) both is and isn’t a rational number. Therefore the assumption was false, which shows that \\(-x\\) is irrational."
  },
  {
    "objectID": "prop_log/axiom_systems.html",
    "href": "prop_log/axiom_systems.html",
    "title": "Axiom Systems",
    "section": "",
    "text": "Finally we can say something about axiomatic systems. In order to discuss this, we should have in mind a few examples of axiomatic systems.\nNote that I will present these systems at a relatively introductory and intuitive level – we will not say anything very detailed, about how to use them, or what they mean."
  },
  {
    "objectID": "prop_log/axiom_systems.html#euclidean-geometry",
    "href": "prop_log/axiom_systems.html#euclidean-geometry",
    "title": "Axiom Systems",
    "section": "Euclidean Geometry",
    "text": "Euclidean Geometry\nEuclidean geometry is the axiom system which describes most of the familiar ideas of geometry. It is made from the following list of axioms.1\n\nThere are some three points which are not colinear.\nFor any two points there is a unique line which runs through them.\nFor any line it contains at least two points.\nA line segment can be prolonged indefinitely.\nFor any two points there is a circle which is centered on one of the points and passing through the other.\nFor any line and point not on the line, there exists a line parallel to the first line, which runs through the point.\n\nHere is an example proposition which can be proved from them:\n\n\n\n\n\n\nTwo Lines, One Intersection\n\n\n\nTheorem: Any two lines intersect in at most one point.\nProof: Suppose for contradiction that some two distinct lines, \\(\\ell_1,\\ell_2\\), intersect at some two distinct points, \\(P_1,P_2\\). Then by defintion, \\(P_1\\in \\ell_1\\) and \\(P_2\\in \\ell_1\\), and also \\(P_1\\in\\ell_2\\) and \\(P_2\\in\\ell_2\\).2\nBy axiom (2.) applied to the facts \\(P_1\\in\\ell_1,P_2\\in\\ell_1\\), there is a unique line running through \\(P_1\\) and \\(P_2\\), and so it must be \\(\\ell_1\\). This just means that if any other line runs through these two points, then it must equal \\(\\ell_1\\).\nBut since we also have \\(P_1\\in\\ell_2,P_2\\in\\ell_2\\), then from what we said immediately above, \\(\\ell_2\\) must be the same line as \\(\\ell_1\\).\nBut this is a contradiction, since our assumption was \\(\\ell_1\\ne\\ell_2\\) but we have now derived \\(\\ell_1=\\ell_2\\).\nSince the assumption that “there are some two lines which intersect at some two points” led to a contradiction, then therefore this must not be true. That is to say, we have proved that any two distinct lines must intersect in at most one point.\n\\(\\Box\\)\n\n\nEuclidean geometry just is the set of all “logical consequences” of the axioms. That is to say, Euclidean geometry is the set of propositions which are entailed by the set of axioms."
  },
  {
    "objectID": "prop_log/axiom_systems.html#peano-arithmetic",
    "href": "prop_log/axiom_systems.html#peano-arithmetic",
    "title": "Axiom Systems",
    "section": "Peano Arithmetic",
    "text": "Peano Arithmetic\nHere are the axioms of Peano arithmetic:\n\n0 is a natural number.\nEvery natural number has a successor.\nIf two numbers share the same successor then they are the same number.\n0 is not the successor of any number.\nInduction is valid.\n\nI’m sure that especially axiom number 5 seems provocative! We will have much more to say about it in the chapter on First Order Logic, but for now I just want to show the various axioms systems at an introductory level. So we won’t currently worry about exactly what is meant by these.\nHere is a very simple example theorem.\n\n\n\n\n\n\nTwo Successors\n\n\n\nTheorem: If two numbers have different successors, then they are different numbers.\nProof: Suppose \\(m,n\\) are two natural numbers and \\(S(m)\\ne S(n)\\).\nSuppose for contradiction that \\(m=n\\). Then \\(S(m)=S(n)\\) but this contradicts \\(S(m)\\ne S(n)\\).\nTherefore \\(m\\ne n\\).\n\\(\\Box\\)"
  },
  {
    "objectID": "prop_log/axiom_systems.html#real-numbers",
    "href": "prop_log/axiom_systems.html#real-numbers",
    "title": "Axiom Systems",
    "section": "Real Numbers",
    "text": "Real Numbers\n\nAddition and multiplication are operations on real numbers. The set of real numbers is closed under this operation.3\nBoth operations are associative and commutative.\nAddition has an identity element, written as \\(0\\). The fact that \\(0\\) is an identity element, means that for any other real number, \\(x\\), the equality \\(0+x=x=x+0\\) holds.\nEvery real number has an “additive inverse”. If \\(x\\) is any real number, then we write its additive inverse as \\(-x\\). The fact that \\(-x\\) is the additive inverse of \\(x\\), means that their sum is the identity. I.e.\n$$\n-x+x = 0\n$$\nEvery real number other than \\(0\\) has a multiplicative inverse. If \\(x\\) is a nonzero real number then we write its multiplicative inverse as \\(x^{-1}\\) or \\(1/x\\). Being the multiplicative inverse means that \\(x\\) and \\(x^{-1}\\) multiply to the identity – but notice that this time the identity is \\(1\\)!\n$$\nx^{-1}\\cdot x = 1\n$$\nMultiplication distributes over addition: For any three real numbers \\(x,y,z\\) we have\n$$\nx(y+z)=xy+xz\n$$\n\n\n\n\n\n\n\nReal Number Demo\n\n\n\nTheorem: Zero times any number is zero.\nProof: Let \\(x\\) be any real number. Then the following chain of equations holds.\n\\[\n0x = (-1+1)x = (-1)x + 1x = (-1)x + x\n\\]\nThe first equation is true because \\(0=-1+1\\), which is an instance of axiom 4. The second equaiton is an application of axiom 6. The third equation is an instance of axiom 3.\nI claim, as a lemma, that \\((-1)x=-x\\). We will see the proof of this lemma in a later section, but for now we take it for granted. Therefore we have\n\\[\n0x = -x+x = 0\n\\]\nwhere the first equation is due to the lemma, and the second equation is an instance of axiom 4.\n\\(\\Box\\)"
  },
  {
    "objectID": "prop_log/axiom_systems.html#zfc",
    "href": "prop_log/axiom_systems.html#zfc",
    "title": "Axiom Systems",
    "section": "ZFC",
    "text": "ZFC\nZFC is perhaps “the big one” because it can be taken as a foundation for almost all of mathematics. However, the axioms can be quite complex and abstract, and therefore it doesn’t make much sense to present them until after we have discussed first-order logic in the next chapter. First-order logic will then equip us with some of the language and concepts that we will need to make sense of these axioms."
  },
  {
    "objectID": "prop_log/abstract_propositions.html",
    "href": "prop_log/abstract_propositions.html",
    "title": "Abstract Propositions",
    "section": "",
    "text": "We looked at two examples of arguments in the previous section, but we don’t want to be too focused on specific cases. Eventually we want to analyze logic itself, so that it can be applied to any propositions that may come up."
  },
  {
    "objectID": "prop_log/abstract_propositions.html#negation",
    "href": "prop_log/abstract_propositions.html#negation",
    "title": "Abstract Propositions",
    "section": "Negation",
    "text": "Negation\nOne way to form a new proposition from the variable \\(P\\) is to negate it. If the proposition \\(P\\) is aligned with \\(x=1\\) then its negation is “\\(x\\) is not equal to 1”, or in more standard mathematical notation, \\(x\\ne 1\\). This flips the truth-value of the proposition being negated.\nTo represent the negation of \\(P\\) we write \\(\\neg P\\).\nBelow is the truth-table for negation.\n\\[\n\\begin{array}{|c||c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P & \\neg  P \\\\ \\hline \\\\\\hline\nT & \\color{red}F  \\\\ \\hline\nF & \\color{red}T  \\\\ \\hline\n\\end{array}\n\\]\nNow that the table is getting sophisticated, I’m adding some extra features. First of all, I’ve shaed the first row and column with a gray background. This is to indicate that the first row is a header row. Also the first column as a kind of header column, because we will just use it to “index” the entries in the body of the truth table.\nThe first “real” content of the table is emphasized below.\n\\[\n\\begin{array}{|c||c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P & \\neg  P \\\\ \\hline \\\\\\hline\nT & \\bf \\color{red}F  \\\\ \\hline\nF & \\color{red}T  \\\\ \\hline\n\\end{array}\n\\]\nThis is computed by first finding the value \\(P\\), which is \\(T\\) on this row. Then we apply the \\(\\neg\\) operation to it, flipping it to \\(F\\) and hence this is the value. The second row of truth-values is computed similarly.\n\n\n\n\n\n\nDouble Negation\n\n\n\nExercise:\nMake the truth-table for \\(\\neg (\\neg P)\\).\nWe say that two propositions are equivalent if they “have the same truth-table”.1 Are \\(P\\) and \\(\\neg(\\neg P)\\) equivalent?\n\n\n\nNegation is also represented in almost every programming language. Below we can see how Python represents truth values, and then see how Python gives the ability to negate them.\n\n\nCode\nprint(not True)\nprint(not False)\n\n\nFalse\nTrue\n\n\n\n\n\n\n\n\nDN in Python\n\n\n\nExercise:\nDemonstrate double-negation (i.e. the equivalence of \\(P\\) and \\(\\neg(\\neg P)\\)) in a Python program."
  },
  {
    "objectID": "prop_log/abstract_propositions.html#disjunction",
    "href": "prop_log/abstract_propositions.html#disjunction",
    "title": "Abstract Propositions",
    "section": "Disjunction",
    "text": "Disjunction\nIf \\(P\\) and \\(Q\\) are any two propositional variables, then to express “\\(P\\) or \\(Q\\)” we write \\(P\\lor Q\\). Note that by saying that either sentence is true, it is enough if just one of them is true. Take for example the sentence “Either the prize is behind the first door or the second door.” If the prize is behind the first door, then that sentence was true. But if the prize was behind the third door (i.e. not the first and not the second), the sentence was false.\nThis is called the disjunction of \\(P\\) and \\(Q\\), and it has the following truth-table.\n\\[\n\\begin{array}{|c|c|ccc|}\\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&Q\\columncolor{lightgray}&P&\\lor &Q\\\\\\hline&&&&\\\\\\hline\nT&T&&\\color{red}T&\\\\\\hline\nT&F&&\\color{red}T&\\\\\\hline\nF&T&&\\color{red}T&\\\\\\hline\nF&F&&\\color{red}F&\\\\\\hline\n\\end{array}\n\\]\nNote that this time the table has four rows (not counting the header row which declares the variables and proposition). This is because there are more possibilities with two variables than with just one. We could have both \\(P\\) and \\(Q\\) true, which is the first row – or we could have one true and the other false, which is the next two rows – or both could be false, which is the final row.\nIn Python we can model this with the disjunction operator.\n\n\nCode\nprint(True or True)\nprint(True or False)\nprint(False or True)\nprint(False or False)\n\n\nTrue\nTrue\nTrue\nFalse\n\n\nIn fact, the above can be done more simply in a couple of “embedded for-loops”, as shown below.\n\n\nCode\ntruth_values = [True, False] # A list of all truth values\nfor P in truth_values: # Iterate through all truth values\n    for Q in truth_values: # Q does likewise\n        print(P or Q) # Compute \"their 'or'\" and print it.\n\n\nTrue\nTrue\nTrue\nFalse\n\n\nThe way that the above code works is: P is a variable, and it will eventually “take” every value from the list [True,False]. Initially it takes the value True.\nAfter P takes True then the code inside, for Q in [True,False]: print(P or Q) executes. But the way that this executes is, similarly, that Q starts by taking the value True. Then the program executes print(P or Q) which is effectively equivalent to print(True or True).\nMaking a long story short, on the next loop iteration, P is still true but Q takes the value False. Then print(P or Q) executes, which is equivalent to print(True or False). Then P ticks over to False and Q starts over at True, and print(P or Q) is equivalent to print(False or True). Then P is False and Q takes True, and print(P or Q) is equivalent to print(False or False).\n\n\n\n\n\n\nNot Loop\n\n\n\nExercise:\nThis code:\n\n\nCode\nprint(not True)\nprint(not False)\n\n\nFalse\nTrue\n\n\ncould instead be implemented with a for-loop. Fill in the parts of the following code where it contains %TODO so that it does the same thing as the code above.\n\n\nCode\nfor P in [True, False]:\n    \"\\%TODO\"\n\n\n\n\n\nIf we use three variables, we can analyze the sentence \\(P\\lor (Q\\lor R)\\). This now requires even more rows of truth-values. How many more?\nWell it should double the number of rows, from how many were needed for two variables. That is because we need to consider two possibilities: Either \\(P\\) is true or it is false. If \\(P\\) is true, then we need to run through all of the remaining four possibilities for \\(Q\\) and \\(R\\). So this half of the truth-table should look like:\n\\[\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nT&T&T\\\\\\hline\nT&T&F\\\\\\hline\nT&F&T\\\\\\hline\nT&F&F\\\\\\hline\n\\end{array}\n\\]\nThen it’s clear what we do for the other half, where \\(P\\) is \\(F\\).\n\\[\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nF&T&T\\\\\\hline\nF&T&F\\\\\\hline\nF&F&T\\\\\\hline\nF&F&F\\\\\\hline\n\\end{array}\n\\]\nPutting these together we get the eight-row truth-table\n\\[\n\\begin{array}{|c|c|c|} \\hline\nP&Q&R\\\\\\hline\\\\\\hline\nT&T&T\\\\\\hline\nT&T&F\\\\\\hline\nT&F&T\\\\\\hline\nT&F&F\\\\\\hline\nF&T&T\\\\\\hline\nF&T&F\\\\\\hline\nF&F&T\\\\\\hline\nF&F&F\\\\\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\nGeneral Row Numbers\n\n\n\nExercise:\nIf there were 4 variables, how many rows would be needed? (Hint: One variable required two rows. Two variables, four rows; three variables, eight row; …)\nIf there were \\(n\\) variables, how many rows would be needed?\n\n\nNow that we know the column and row “headers” we can fill in the table for \\(P\\lor Q\\lor R\\). However, doing it all at once can be difficult to parse, so let’s do this in stages. First let’s merely populate the columns under the variables – this is a tedious transcription.\n\\[\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&\\columncolor{lightgray}Q&\\columncolor{lightgray}R&&P&\\lor &(Q&\\lor &R)\\\\\\hline&&&&&&&\\\\\\hline\nT&T&T && T &  & T &  & T\\\\\\hline\nT&T&F && T &  & T &  & F\\\\\\hline\nT&F&T && T &  & F &  & T\\\\\\hline\nT&F&F && T &  & F &  & F\\\\\\hline\nF&T&T && F &  & T &  & T\\\\\\hline\nF&T&F && F &  & T &  & F\\\\\\hline\nF&F&T && F &  & F &  & T\\\\\\hline\nF&F&F && F &  & F &  & F\\\\\\hline\n\\end{array}\n\\]\nNow we try to fill in the values under any operators. However, if we look at the first \\(\\lor\\) operator, we cannot fill it in! This is because it must “read” the value to its left and right. The values to the left are there, but the values to the right come from everything inside \\((Q\\lor R)\\). These values should be read from what appears under the \\(\\lor\\) and they are blank. Therefore we must fill these in first.\nTo fill in the values under \\((Q\\lor R)\\), we get the following table. Notice that the first row is computed as \\(T\\lor T=T\\). The second is \\(T\\lor F=T\\) and the third is \\(F\\lor T = T\\) and the fourth is \\(F\\lor F=F\\), and so on. Because this column of computation is derived from others, I will color it.\n\\[\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&\\columncolor{lightgray}Q&\\columncolor{lightgray}R&&P&\\lor &(Q&\\lor &R)\\\\\\hline &&&&&&&\\\\\\hline\nT&T&T && T &  & T & \\color{blue}T & T\\\\\\hline\nT&T&F && T &  & T & \\color{blue}T & F\\\\\\hline\nT&F&T && T &  & F & \\color{blue}T & T\\\\\\hline\nT&F&F && T &  & F & \\color{blue}F & F\\\\\\hline\nF&T&T && F &  & T & \\color{blue}T & T\\\\\\hline\nF&T&F && F &  & T & \\color{blue}T & F\\\\\\hline\nF&F&T && F &  & F & \\color{blue}T & T\\\\\\hline\nF&F&F && F &  & F & \\color{blue}F & F\\\\\\hline\n\\end{array}\n\\]\nAnd now that this column has been populated, the column under the first \\(\\lor\\) now “sees” all the values that it needs to compute. Therefore we do this in the table below. Note that the first row is computed as \\(T\\lor{\\color{blue} T}=\\color{red}T\\), and the fourth row is computed as \\(T\\lor {\\color{blue} F}=\\color{red} T\\), for two illustrations.\n\\[\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&\\columncolor{lightgray}Q&\\columncolor{lightgray}R&&P&\\lor &(Q&\\lor &R)\\\\\\hline&&&&&&&&\\\\\\hline\nT&T&T && T & \\color{red}T & T & \\color{blue}T & T\\\\\\hline\nT&T&F && T & \\color{red}T & T & \\color{blue}T & F\\\\\\hline\nT&F&T && T & \\color{red}T & F & \\color{blue}T & T\\\\\\hline\nT&F&F && T & \\color{red}T & F & \\color{blue}F & F\\\\\\hline\nF&T&T && F & \\color{red}T & T & \\color{blue}T & T\\\\\\hline\nF&T&F && F & \\color{red}T & T & \\color{blue}T & F\\\\\\hline\nF&F&T && F & \\color{red}T & F & \\color{blue}T & T\\\\\\hline\nF&F&F && F & \\color{red}F & F & \\color{blue}F & F\\\\\\hline\n\\end{array}\n\\]\nAs usual, the truth-table of the proposition is highlighted in red.\n\n\n\n\n\n\nPython Triple Disjunction\n\n\n\nExercise:\nDemonstrate a couple of rows of the truth-table above in some Python code. For instance, run stuff like True or (False or False).\n\n\n\n\n\n\n\n\nFinite Disjunction\n\n\n\nExercise:\nThe following Python code computes the truth-table for \\(P\\lor(Q\\lor R)\\).\n\n\nCode\nfor P in [True, False]:\n    for Q in [True, False]:\n        for R in [True, False]:\n            print(P or (Q or R))\n\n\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nFalse\n\n\nWrite Python code to compute the truth-table for \\(P\\lor(Q\\lor (R\\lor S))\\).\nWhen you have, note that the only row at which the table is false, is the last row.\n\nIn general, a disjunction of \\(n\\) variables will be true if how many of the variables take the value \\(T\\)?\n\n\n\n\n\n\n\n\nDisjunction Associativity\n\n\n\nExercise:\nI claim that \\(P\\lor (Q\\lor R)\\) is equivalent to \\((P\\lor Q)\\lor R\\). Write a Python program to prove that this is true.\nThis fact is called the associativity of disjunction.\n\nI also claim that disjunction is commutative which means \\(P\\lor Q\\) is equivalent to \\(Q\\lor P\\). Write a Python program to prove whether this is true.\n\n\n\n\n\n\n\n\nParsing Ambiguity\n\n\n\nExercise:\nMake a truth table for both \\(\\neg (P\\lor Q)\\) and \\((\\neg P)\\lor Q\\), and check your answers with the following Python code.\n\n\nCode\nfor P in [True, False]:\n    for Q in [True, False]:\n        print(not (P or Q))\n\nprint() # Just print a blank line to help see the separation of the two tables.\n\nfor P in [True, False]:\n    for Q in [True, False]:\n        print((not P) or Q)\n\n\nFalse\nFalse\nFalse\nTrue\n\nTrue\nFalse\nTrue\nTrue\n\n\nThen use these two truth-tables to argue that these two propositions are not equivalent.\nUse the above result to argue that \\(\\neg P\\lor Q\\) is meaningless.\nHowever, although \\(\\neg P\\lor Q\\) is technically meaningless, we will in fact assume that if we ever write \\(\\neg P\\lor Q\\) it is actually short-hand for \\((\\neg P)\\lor Q\\). The more general rule is that\n\nNegation takes precedence.\n\nThat is to say, in any abstract logical expression in which negation occurs, we will assume that it applies first.\n\nAlso, technically \\(P\\lor Q\\lor R\\) is meaningless because we technically require parentheses to distinguish between \\(P\\lor (Q\\lor R)\\) and \\((P\\lor Q)\\lor R\\).\nHowever, since we have seen that these are equivalent, in fact the ambiguity is unimportant. We will therefore feel free to write down \\(P\\lor Q\\lor R\\) and the reader is free to decide for themselves whether this means \\(P\\lor (Q\\lor R)\\) or \\((P\\lor Q)\\lor R\\) – whichever one the reader likes best!"
  },
  {
    "objectID": "prop_log/abstract_propositions.html#conjunction",
    "href": "prop_log/abstract_propositions.html#conjunction",
    "title": "Abstract Propositions",
    "section": "Conjunction",
    "text": "Conjunction\nHaving done all that work for disjunction, conjunction is mostly trivial. It represents the proposition “\\(P\\) and \\(Q\\)”, we write this symbolically as \\(P\\land Q\\), and it has the following truth-table.\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&\\columncolor{lightgray}Q&&P&\\land &Q\\\\\\hline &&&&&\\\\\\hline\nT&T&&T&\\color{red}T&T\\\\\\hline\nT&F&&T&\\color{red}F&F\\\\\\hline\nF&T&&F&\\color{red}F&T\\\\\\hline\nF&F&&F&\\color{red}F&F\\\\\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\nConjunction Catchall\n\n\n\nExercise:\nRe-do all the exercises for disjunction but this time for conjunction, noting any interesting dissimilarities.\n\n\n\n\n\n\n\n\nDistribution\n\n\n\nExercise:\nShow (either in a table or a program) that \\(P\\land (Q\\lor R)\\) is not equivalent to \\((P\\land Q)\\lor R\\) and conclude that “conjunction and disjunction do not associate”.2\nHowever, show that \\(P\\land (Q\\lor R)\\) is equivalent to \\((P\\land Q) \\lor (P\\land R)\\). Also, come up with a corresponding equivalence for \\(P\\lor (Q\\land R)\\) and prove that it’s equivalent.\nThe above is called the distribution of \\(\\land\\) over \\(\\lor\\) (and conversely). This is similar to how multiplication distributes over addition.\n\\[\nx(y+z) = xy+xz\n\\]\nHowever, note that addition does not distribute over multiplication.\n\\[\nx+yz \\ne (x+y)(x+z)\n\\]\nTherefore these logical operators are “more distributive” than the mathematical operators. Each distributes over the other, whereas in mathematics, it is only that multiplication distributes over addition."
  },
  {
    "objectID": "prop_log/abstract_propositions.html#the-conditional",
    "href": "prop_log/abstract_propositions.html#the-conditional",
    "title": "Abstract Propositions",
    "section": "The Conditional",
    "text": "The Conditional\nThe conditional is, in a sense, no different from the other logical symbols. It is meant to represent propositions of the form “If \\(P\\) then \\(Q\\).” It has symbol \\(\\to\\) and truth-table\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\columncolor{lightgray}\\rowcolor{lightgray}P&\\columncolor{lightgray}Q&&P&\\to &Q\\\\\\hline&&&&\\\\\\hline\nT&T&&T&\\color{red}T&T\\\\\\hline\nT&F&&T&\\color{red}F&F\\\\\\hline\nF&T&&F&\\color{red}T&T\\\\\\hline\nF&F&&F&\\color{red}T&F\\\\\\hline\n\\end{array}\n\\]\nHowever, this truth-table is probably perplexing. Let’s try to see the correspondence between a sentence of the form “If \\(P\\) then \\(Q\\).” and this truth-table. Consider these four examples:\n\n\n\n\n\n\nIf Then Example\n\n\n\nExample:\nIf the sun is out, then the weather is warm.\n\n\nNow consider each of the four possibilities. The first is that the sun is out and the weather is warm. Well, it makes sense that the sentence was true in this case. This explains the first row, since we aligned \\(P\\) with a true sentence, \\(Q\\) with a true sentence, and the result is a true sentence.\nNext consider the possibility that the sun is out, but because you live in the South Pole, the weather is cold. In this case, the sentence was false. This explains the second row since \\(P\\) is true and \\(Q\\) false.\nSo far I think everything makes pretty immediate sense, but the next two possibilities are the ones that most people struggle with the most. What is especially difficult about them is that \\(P\\) is false. A sentence of the form “If \\(P\\) then \\(Q\\).” is quite literally predicated upon the assumption of \\(P\\), so it becomes quite difficult to think about what one should say if \\(P\\) is false.\nIn the table, it is clear that we have decided that, when \\(P\\) is false, the conditional sentence is true (regardless of the truth-value of \\(Q\\)). You can imagine that it behaves like a promise: “I promise that, IF the sun is out, then the weather is warm.” When the condition of the promise is removed, because say the sun is not out, then the promise is so-to-speak nullified – and we say that the speaker was speaking the truth.\nIn the example of the sun and the weather, imagine the “false-true” case in which the sun is not out but the weather is still warm. In that case, we regard the speaker as not wrong, because the condition of the sentence was not met. And similarly, in the false-false case whether the sun is not out and the weather is not warm, again the speaker is still speaking the truth.3\n\n\n\n\n\n\nConditional Properties\n\n\n\nShow that the conditional is neither associative nor commutative.\n\n\n\n\n\n\n\n\nAntecedent and Consequent\n\n\n\nBecause the conditional is not commutative, it now makes sense to have vocabulary for talking about the left- and right-side of the \\(\\to\\) symbol. If \\(\\alpha\\) and \\(\\beta\\) are any two propositions4 then for the conditional proposition \\(\\alpha\\to\\beta\\) we call \\(\\alpha\\) the antecedent and \\(\\beta\\) the consequent.\nFor disjunction and conjunction such a distinction makes no sense, but it will still be worthwhile to have vocabulary to talk about the component sentences. So for instance, in the conjunction proposition \\(\\alpha\\land\\beta\\), we call \\(\\alpha\\) and \\(\\beta\\) the conjuncts of the conjunction. We also call them the disjuncts of the disjunction \\(\\alpha\\lor\\beta\\).\n\n\nBesides having the most confusing truth-table, the conditional also is the hardest to translate to and from natural language. Of course if we say “If a polygon has three angles then it is a triangle,” then we would align \\(P\\) with the sentence “the polygon has three angles” and \\(Q\\) with “the polygon is a triangle”. The the entire proposition is aligned with \\(P\\to Q\\).\nHowever, the first clause is not always the one that goes to the left of the \\(\\to\\). The example sentence is equivalent to “The polygon is a triangle if it has three angles.” This makes it seem as though the clause after the word “if” will always appear to the left of the \\(\\to\\).\nHowever, even this is not true! The sentence “The polygon is a triangle only if it has three angles” is equivalent to “If the polygon is a triangle then it has three angles”! This one is often especially confusing to a new student, learning about the conditional.\nTo help make the “only if” construction clearer, imagine a castle which is only accessible by a bridge, which is guarded by a knight.\n\n\n\n\n\nThen the sentence “You can enter the castle only if you take the bridge” can be stated as the if-then sentence\n\nIf you are in the castle then you took the bridge.\n\nNote that the reverse is not true: If you take the bridge, you might not enter the castle – the knight might still stab you in the head and you’ll never make it to the castle!\n\n\n\n\n\n\nOnly If\n\n\n\nExercise:\nLet \\(P\\) be the proposition “\\(x+1 = 2\\)” and let \\(Q\\) be the proposition “\\(x=1\\)”. Is the proposition “\\(x+1=2\\) only if \\(x=1\\)” the same as \\(P\\to Q\\) or \\(Q\\to P\\)?\n\n\n\n\n\n\n\n\nOnly If\n\n\n\nExercise:\nGo back to the two examples in the previous section (link here) and identify all instances of if-then sentences."
  },
  {
    "objectID": "prop_log/abstract_propositions.html#biconditional",
    "href": "prop_log/abstract_propositions.html#biconditional",
    "title": "Abstract Propositions",
    "section": "Biconditional",
    "text": "Biconditional\nBecause it comes up so often, we will use the symbol \\(\\leftrightarrow\\) as an abbreviation for \\((P\\to Q) \\land (Q\\to P)\\). It is often represented in English by a sentence of the form “\\(P\\) if and only if \\(Q\\)”. This form doesn’t come up extremely often in natural scenarios, but it comes up in mathematics everywhere.\n\n\n\n\n\n\nBiconditional Truth Table\n\n\n\nExercise:\nProduce the truth-table for \\(P\\leftrightarrow Q\\), and show that \\(\\leftrightarrow\\) is both commutative and associative."
  },
  {
    "objectID": "fol/pred.html",
    "href": "fol/pred.html",
    "title": "Predicate Logic",
    "section": "",
    "text": "In this chapter we extend propositional logic to another logic with more expressive power. In this section, we introduce predicate logic, and in a future section we will extend it to first-order logic."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "How to Become a Mathematician",
    "section": "",
    "text": "test change Welcome to How to Become a Mathematician! This is a web book which will try to explain how mathematicians reason about their subject. We will see\n\nFormal logic\nAxiomatic systems\nProof techniques\nAttempts to formulate and then answer mathematical questions\nProofs of some famous and essential theorems\n\nOf course this is not really about how to become a mathematician, since the usual and most efficient path to actually becoming a mathematician is to study mathematics at university.\n\nPrerequisites\nThe only mathematical prerequisite is basic algebra.\nMany exercises will ask you to write and run Python code using the SymPy and matplotlib libraries. Therefore you will need Python installed with these libraries. Just about any version of Python 3 should be fine.\nI will also have appendices containing information on how to write Python programs. Although I try to keep the information at an introductory level, the reader will need to know about using a computer, enough to set up a standard “Hello World” Python program.\n\n\nWho Is This For?\nIt is for people who are interested in understanding how mathematics gets done. I write this, having in mind some readers who are merely curious, and some readers who hope to become mathematicians.\n\n\nRecommended Usage\n\nMathematicians read with a pencil in hand!\n\nThe above is well-known and often repeated by mathematicians. This is a pretty serious and technical mathematics book, so you won’t have much chance of learning from it without doing the exercises! But in this textbook, many of the exercises are programming exercises written in Python. So besides a pencil, you’ll also need a Python IDE.\nThis is published at How to Become a Mathematician and the source documents are publicly available at my Axiom Tutor.\n\nOne way to use this online textbook is to put the textbook on one side of your screen and a Python IDE on the other. For this, this website is sufficient.\n\nAnother way is to download the source files from the GitHub repository. Then open them either in VSCode or RStudio. The source files (the ones with extension .qmd) are written in Quarto, which is a slightly beefy version of Markdown. Therefore, once you’ve opened the source files in an appropriate editor, you can edit them directly and insert code cells to write your solutions for exercises.\n\nI think the second way sounds the nicest to me. You can then make the textbook “your own”, with notes and exercise solutions inserted in the middle of the text, where and how you want them.\nHowever, the first way is somewhat more flexible and might even be possible on mobile devices. So I can understand how some people might prefer either way.\n\n\nStatus\nAs of writing this in July 2023, I have not yet finished the first chapter (of several to come). This website may undergo heavy redesign before it is finished."
  },
  {
    "objectID": "prop_log/ancient_greek.html",
    "href": "prop_log/ancient_greek.html",
    "title": "Ancient Greece",
    "section": "",
    "text": "The study of logic has two origins, philosophy and geometry. In many places throughout the world, people tried to establish rules of logic in order to clarify and resolve philosophical and political arguments.\nHowever, in ancient Greece, there was a rather different context in which logic was studied.\n\nThe Logic Network\nOver several centuries, the cultures of Greece, Babylon, Egypt, and more, all had discovered thousands of geometric ideas and theorems.1 For instance, it was known that\n\nThe interior angles of a triangle sum to 180 degrees.\nThe Pythagorean theorem, relating the side lengths of a right triangle.\nFor any line and point not on the line, there is a parallel line through the point.\n\n\nThey knew much more besides.\nBut it sometimes turned out that they would know fact A which implied some other fact B – but then later they would discover that, also, fact B implies fact A! For example consider\n\n\n\n\n\n\nFact A\n\n\n\nFor every line \\(\\ell\\) and point \\(P\\) not on \\(\\ell\\), there is a line \\(\\ell'\\) passing through \\(P\\) parallel to \\(\\ell\\).\n\n\n\n\n\n\n\n\nFact B\n\n\n\nFor every triangle \\(T\\) the sum of its interior angles is \\(180^\\circ\\).\n\n\nWe will see in a few chapters from now, that it is actually possible to prove Fact B from Fact A, and we can prove Fact A from Fact B.2\nThis inspires the question: Which fact is more foundational? If we are to share a common language and understanding of mathematics, we should try to agree upon a shared foundation. From this we can derive its various consequences.\nThis is both a matter of convincing each other of the logical soundness of the arguments, as well as a matter of organizing our body of shared knowledge. By understanding which facts are logical consequences of other more foundational, we can view the body of mathematical facts as a tree-like structure.\n\n\nCode\ngraph G {\n    \"Fact A\" -- \"Consequence AB\";\n    \"Fact B\" -- \"Consequence AB\";\n    \"Fact C\" -- \"Consequence ACD\";\n    \"Fact D\" -- \"Consequence ACD\";\n    \"Fact A\" -- \"Consequence ACD\";\n    \"Fact C\" -- \"Consequence (AB)C\"\n    \"Consequence AB\" -- \"Consequence (AB)C\"\n}\n\n\n\n\n\n\nG\n\n\n\nFact A\n\nFact A\n\n\n\nConsequence AB\n\nConsequence AB\n\n\n\nFact A--Consequence AB\n\n\n\n\nConsequence ACD\n\nConsequence ACD\n\n\n\nFact A--Consequence ACD\n\n\n\n\nConsequence (AB)C\n\nConsequence (AB)C\n\n\n\nConsequence AB--Consequence (AB)C\n\n\n\n\nFact B\n\nFact B\n\n\n\nFact B--Consequence AB\n\n\n\n\nFact C\n\nFact C\n\n\n\nFact C--Consequence ACD\n\n\n\n\nFact C--Consequence (AB)C\n\n\n\n\nFact D\n\nFact D\n\n\n\nFact D--Consequence ACD\n\n\n\n\n\n\n\n\n\n\nAxiomatic Mathematics\nLater when we return to study geometry, we will try to identify the “axioms” of geometry. These will be the foundational truths upon which every other fact of geometry follows. Indeed geometry isn’t the only subject which can be constructed axiomatically, and we will see in later chapters that there are many other axiom systems. These include\n\nArithmetic\nReal numbers\nSet theory\n\nIn fact it will turn out that by organizing these subjects axiomatically will create an unexpected value! We will consider the possibility of removing or adding certain axioms, and see how this can produce new fields of mathematics!\nTest new line####\n\n\n\n\n\nFootnotes\n\n\nOf course other civilizations also had highly developed mathematical knowledge. Especially the ancient Hindus seem to have developed a large body of knowledge independently, and they studied logic with some depth. However, for whatever reason, they never developed axiomatic mathematics – and for that reason, they are not the focus of our story here.↩︎\nOther facts are also needed – the “Euclidean postulates”.↩︎"
  },
  {
    "objectID": "prop_log/copy_ancient_greek.html",
    "href": "prop_log/copy_ancient_greek.html",
    "title": "Ancient Greece",
    "section": "",
    "text": "The study of logic has two origins, philosophy and geometry. In many places throughout the world, people tried to establish rules of logic in order to clarify and resolve philosophical and political arguments.\nHowever, in ancient Greece, there was a rather different context in which logic was studied.\n\nThe Logic Network\nOver several centuries, the cultures of Greece, Babylon, Egypt, and more, all had discovered thousands of geometric ideas and theorems.1 For instance, it was known that\n\nThe interior angles of a triangle sum to 180 degrees.\nThe Pythagorean theorem, relating the side lengths of a right triangle.\nFor any line and point not on the line, there is a parallel line through the point.\n\n\nThey knew much more besides.\nBut it sometimes turned out that they would know fact A which implied some other fact B – but then later they would discover that, also, fact B implies fact A! For example consider\n\n\n\n\n\n\nFact A\n\n\n\nFor every line \\(\\ell\\) and point \\(P\\) not on \\(\\ell\\), there is a line \\(\\ell'\\) passing through \\(P\\) parallel to \\(\\ell\\).\n\n\n\n\n\n\n\n\nFact B\n\n\n\nFor every triangle \\(T\\) the sum of its interior angles is \\(180^\\circ\\).\n\n\nWe will see in a few chapters from now, that it is actually possible to prove Fact B from Fact A, and we can prove Fact A from Fact B.2\nThis inspires the question: Which fact is more foundational? If we are to share a common language and understanding of mathematics, we should try to agree upon a shared foundation. From this we can derive its various consequences.\nThis is both a matter of convincing each other of the logical soundness of the arguments, as well as a matter of organizing our body of shared knowledge. By understanding which facts are logical consequences of other more foundational, we can view the body of mathematical facts as a tree-like structure.\n\n\nCode\ngraph G {\n    \"Fact A\" -- \"Consequence AB\";\n    \"Fact B\" -- \"Consequence AB\";\n    \"Fact C\" -- \"Consequence ACD\";\n    \"Fact D\" -- \"Consequence ACD\";\n    \"Fact A\" -- \"Consequence ACD\";\n    \"Fact C\" -- \"Consequence (AB)C\"\n    \"Consequence AB\" -- \"Consequence (AB)C\"\n}\n\n\n\n\n\n\nG\n\n\n\nFact A\n\nFact A\n\n\n\nConsequence AB\n\nConsequence AB\n\n\n\nFact A--Consequence AB\n\n\n\n\nConsequence ACD\n\nConsequence ACD\n\n\n\nFact A--Consequence ACD\n\n\n\n\nConsequence (AB)C\n\nConsequence (AB)C\n\n\n\nConsequence AB--Consequence (AB)C\n\n\n\n\nFact B\n\nFact B\n\n\n\nFact B--Consequence AB\n\n\n\n\nFact C\n\nFact C\n\n\n\nFact C--Consequence ACD\n\n\n\n\nFact C--Consequence (AB)C\n\n\n\n\nFact D\n\nFact D\n\n\n\nFact D--Consequence ACD\n\n\n\n\n\n\n\n\n\n\nAxiomatic Mathematics\nLater when we return to study geometry, we will try to identify the “axioms” of geometry. These will be the foundational truths upon which every other fact of geometry follows. Indeed geometry isn’t the only subject which can be constructed axiomatically, and we will see in later chapters that there are many other axiom systems. These include\n\nArithmetic\nReal numbers\nSet theory\n\nIn fact it will turn out that by organizing these subjects axiomatically will create an unexpected value! We will consider the possibility of removing or adding certain axioms, and see how this can produce new fields of mathematics!\n\n\n\n\n\nFootnotes\n\n\nOf course other civilizations also had highly developed mathematical knowledge. Especially the ancient Hindus seem to have developed a large body of knowledge independently, and they studied logic with some depth. However, for whatever reason, they never developed axiomatic mathematics – and for that reason, they are not the focus of our story here.↩︎\nOther facts are also needed – the “Euclidean postulates”.↩︎"
  },
  {
    "objectID": "prop_log/deduction.html",
    "href": "prop_log/deduction.html",
    "title": "Deduction",
    "section": "",
    "text": "Entailment is about which propositions “make” other propositions “necessary”. That is to say, if \\(\\Delta\\vDash \\alpha\\) then the truth of \\(\\Delta\\) “makes” \\(\\alpha\\) true, so-to-speak. Deduction, on the other hand, is about demonstrating something more like “reasons why” the entailment holds.\nTake for example the fact that \\(\\frac{xy}{z}+wx = 1\\) for real numbers \\(w,x,y,z\\) with \\(z\\ne 0\\), entails \\(w=\\frac 1 x - \\frac y z\\). It’s all good and well that this entailment holds – but we want a proof! A proof is like receipts, something you can check to validate a claim."
  },
  {
    "objectID": "prop_log/deduction.html#conditional-introduction",
    "href": "prop_log/deduction.html#conditional-introduction",
    "title": "Deduction",
    "section": "Conditional Introduction",
    "text": "Conditional Introduction\nYou will no doubt have noticed that most operations have an elimination and an introduction rule, but with one conspicuous exception. There is no conditional introduction rule! The reason for this omission is that the conditional introduction rule requires a new technique that we will introduce here.\nIt is perhaps easiest to simply give a demonstration. Suppose that we would like to prove \\(\\{P\\lor Q\\} \\vdash \\neg P\\to Q\\). Intuitively, the argument would go like this: “Suppose that \\(\\neg P\\) is true. Well then, we now have \\(\\{P\\lor Q,\\neg P\\}\\) as our premise. In that case we can use Disjunction Elimination to infer \\(Q\\). Since the supposition of \\(\\neg P\\) leads to \\(Q\\), we can therefore infer that ‘If \\(\\neg P\\) then \\(Q\\).’”\nThis is effectively a “subproof”. That is to say, we assume \\(\\neg P\\) and then conduct a proof of something (in this example, that “something” is \\(Q\\)). At the end of the subproof, we then “export” a conditional proposition. The conditional has, as its antecedent, whatever we assumed for the subproof. It has as its consequent, whatever the subproof ended with. In the two-column system we would represent the subproof like this:\n\\[\n\\definecolor{subtl}{rgb}{.95,.95,.85}\n\\begin{array}{|c|c|c|} \\hline\n\\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n1. & P\\lor Q & \\text{Premise} \\\\ \\rowcolor{subtle}\n2. & \\neg P\\to Q &\n\\begin{array}{|c|c|c|} \\hline\n\\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n2.1. & \\neg P & \\text{$\\to$ Assumption} \\\\\\hline \\rowcolor{subtl}\n2.2. & Q & \\lor\\text{E}, 1., 2.1. \\\\\\hline\n\\end{array} \\\\\\hline\n\\end{array}\n\\]\nNotice that the justification for line 2 is the subproof. Also notice the system that we adopt for numbering lines in a subproof. In the subproof on line number 2, the reason is \\(\\lor\\)E, 1, 2.1. What this means is that, of course, line 1 contains \\(P\\lor Q\\). But where is 2.1? It is on line 2 of the main proof, but inside of line 2 we refer to line 1 of the subproof there. This is where we find the proposition \\(\\neg P\\).\nAnd indeed, from \\(P\\lor Q\\) and \\(\\neg P\\) we are able to infer, with Disjunction Elimination, the proposition \\(Q\\). This is what I have entered at line 2.2.\n\nHere’s another example where I prove that \\(\\{P\\to Q\\}\\vdash \\{P\\to (R\\lor Q)\\}\\).\n\\[\n\\begin{array}{|c|c|c|}\\hline\n    \\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n    1. & P\\to Q & \\text{Premise} \\\\\\hline \\rowcolor{subtle}\n    2. & P\\to (R\\lor Q) &\n        \\begin{array}{|c|c|c|}\\hline\n        \\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n        2.1. & P & \\text{$\\to$Assumption} \\\\ \\rowcolor{subtl}\n        2.2. & Q & \\to\\text{E}, 1., 2.1.\\\\\n        2.3. & R\\lor Q & \\lor\\text{I}, 2.2. \\\\ \\hline\n        \\end{array}\\\\\\hline\n\\end{array}\n\\]\nAgain notice how this works: We want to prove \\(P\\to (R\\lor Q)\\), so we make a subproof with assumption \\(P\\) and ending at \\(R\\lor Q\\).\n\nHere’s an example of a proof with no premises. This is in fact possible because the Conditional Introduction does not require there to be any premises – it allows you to make any assumption that you want, at any time!\nWe will prove \\(\\emptyset\\vdash P\\to P\\).\n\\[\n\\begin{array}{|c|c|c|}\\hline\n\\text{No.} & \\text{Prop} & \\text{Reason} \\\\ \\hline\n1. & P\\to P &\n  \\begin{array}{|c|c|c|}\\hline\n  \\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n  1.1. & P & \\to\\text{Assumption} \\\\ \\rowcolor{subtle}\n  1.2. & P & \\text{Reit}, 1.1. \\\\ \\hline\n  \\end{array}\\\\\\hline\n\\end{array}\n\\]\nThis might seem like a strange argument. What is this “Reit”? It is the Reiteration rule that was introduced in the long list of various inference rules. It says, effectively, that if a proposition is on any line in a proof, then on a later line we can always choose to “reiterate” it on a new line.\nThis is pretty much only useful in conditional proofs, where we really need the last line of the proof to be our “target” consequent of the conditional. In this case we needed it to be \\(P\\), because that is the consequent of the proposition that we’re proving, \\(P\\to P\\).\n\nLet’s next see a proof from no premises that \\(\\emptyset\\vdash (P\\land (P\\to Q))\\to Q\\).\n\\[\n\\begin{array}{|c|c|c|}\\hline\n\\text{No.}&\\text{Prop}&\\text{Reason}\\\\\\hline\n1. & (P\\land(P\\to Q))\\to Q &\n  \\begin{array}{|c|c|c|}\\hline\n  1.1. & P\\land(P\\to Q)& \\to\\text{Assumption} \\\\ \\rowcolor{subtle}\n  1.2. & P & \\land\\text{E},1.1.\\\\\n  1.3. & P\\to Q & \\land\\text{E},1.1\\\\\\rowcolor{subtle}\n  1.4. & Q & \\to\\text{E},1.2.,1.3. \\\\\n  \\hline\n  \\end{array}\\\\\\hline\n\\end{array}\n\\]\n\nRestrictions on Conditional Proof\nI have not yet really specified the rules of conditional proof, because they can be somewhat difficult to understand. For now I have mostly tried to communicate the method by examples. However, take the following example which demonstrates that this technique is invalid if used in the wrong ways.\n\\[\n\\begin{array}{|c|c|c|} \\hline\n\\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n1. & P\\to (P\\lor Q) &\n  \\begin{array}{|c|c|c|} \\hline\n  1.1. & P & \\text{Assumption} \\\\ \\rowcolor{subtle}\n  1.2. & P\\lor Q & \\lor\\text{I},1.1\\\\\\hline\n  \\end{array} \\\\ \\rowcolor{subtle}\n2. & P & \\text{Reit}, 1.1 \\\\\\hline\n\\end{array}\n\\]\nNotice that the above argument only uses our inference rules, so it seems like an acceptable proof! Does that mean that our Conditional Introduction rule is invalid?\nIf it is used “unrestrictedly” then yes. Therefore we must place restrictions on it, so that the rule will be valid. The problem with the above proof, is the very last step. On line 2, it justifies writing a proposition ( \\(P\\)) based on a line (1.1.) which was only introduced for conditional proof. But lines that occur in a subproof are only meant to be used for the subproof and not outside of it.\nSince this is the source of the invalidity, this is precisely the restriction that we place on all proofs: On any line of a proof, one is only allowed to reference lines which do not come from a “closed” subproof. So for instance, in the above proof it is fine for like 1.2 to reference 1.1, because at line 1.2 the subproof is not yet closed. But at line 2. it is not acceptable to reference line 1.1 because that occurs in a subproof which, by line 2 has already been closed.\n\n\n\n\n\n\nValid References\n\n\n\nConsider the following proof.\n\\[\n\\begin{array}{|c|c|c|}\\hline\n  \\text{No.}&\\text{Prop}&\\text{Reason}\\\\\\hline\n  1. & (P\\land Q) \\to P &\n    \\begin{array}{|c|c|c|}\\hline\n    \\text{No.}&\\text{Prop}&\\text{Reason}\\\\\\hline\n    1.1. & P\\land Q & \\to\\text{Assumption}\\\\\\rowcolor{subtle}\n    1.2. & P & \\land\\text{E} \\\\\\hline\n    \\end{array}\\\\\\hline\\rowcolor{subtle}\n  2. & P & \\to\\text{E}, 1., 1.1. \\\\\\hline\n\\end{array}\n\\]\nIs this a valid argument? If not, at which line is an invalid inference made?"
  },
  {
    "objectID": "prop_log/deduction.html#proof-by-contradiction",
    "href": "prop_log/deduction.html#proof-by-contradiction",
    "title": "Deduction",
    "section": "Proof by Contradiction",
    "text": "Proof by Contradiction\nThere is a second proof method which uses subproofs. This is proof by contradiction. Consider the following argument which illustrates the technique.\n\nWe will prove that there is no largest number. For contradiction, suppose that there is a largest number and call it \\(x\\). Then \\(x+1\\) is a number and larger. Therefore \\(x\\) is both largest (by assumption) and not largest (because there is a larger number). This is a contradiction. Because the assumption that there is a largest number produced a contradiction, then the assumption must be false. So there is no largest number.\n\nThe idea is that we\n\nAssume the negation of what you hope to prove. (e.g. “there is a largest number”)\nFrom the assumption, derive a contradiction. (“\\(x\\) is largest and not largest”)\nTherefore end the subproof, and infer what you wanted to prove. (“there is no largest number”)\n\nBelow I’ll illustrate this technique in a two-column proof that \\(\\{P\\lor Q\\}\\vdash \\neg(\\neg P\\land\\neg Q)\\).\n\\[\n\\begin{array}{|c|c|c|}\\hline\n\\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n1. & P\\lor Q & \\text{Premise} \\\\ \\rowcolor{subtle}\n2. & \\neg(\\neg P\\land \\neg Q) &\n  \\begin{array}{|c|c|c|}\\hline\n  \\text{No.} & \\text{Prop} & \\text{Reason} \\\\\\hline\n  2.1. & \\neg(\\neg(\\neg P\\land \\neg Q)) & \\unicode{x21af} \\text{Assumption}\\\\\\rowcolor{subtl}\n  2.2. & \\neg P\\land \\neg Q & \\neg\\text{E},2.1. \\\\\n  2.3. & \\neg P & \\land\\text{E},2.2. \\\\ \\rowcolor{subtl}\n  2.4. & \\neg Q & \\land \\text{E},2.2. \\\\\n  2.5. & Q & \\lor\\text{E},1.,2.4. \\\\ \\rowcolor{subtl}\n  2.6. & Q\\land\\neg Q& \\land\\text{I}, 2.4.,2.5.\\\\\\hline\n\\end{array} \\\\ \\hline\n\\end{array}\n\\]\nNotice how the subproof in line 2 ends on the contradiction \\(Q\\land\\neg Q\\). Every proof by contradiction must end on a line containing \\(\\alpha\\land\\neg\\alpha\\) or \\(\\neg\\alpha\\land\\alpha\\), for some proposition \\(\\alpha\\).\n\nHere is a proof that \\(\\{\\neg(P\\land Q)\\}\\vdash \\neg P\\lor\\neg Q\\). This will be somewhat interesting in that it has a subproof within a subproof!\n\\[\n\\begin{array}{|c|c|c|}\\hline\n\\text{No.}&\\text{Prop}&\\text{Reason} \\\\\\hline\n1. & \\neg(P\\land Q) & \\text{Premise}\\\\ \\rowcolor{subtle}\n2. & \\neg P\\lor\\neg Q &\n  \\begin{array}{|c|c|c|}\\hline\n  \\text{No.}&\\text{Prop}&\\text{Reason} \\\\\\hline\n  2.1 & \\neg(\\neg P\\lor \\neg Q) & \\unicode{x21af}\\text{Assumption}\\\\ \\rowcolor{subtl}\n  2.2. & P &\n    \\begin{array}{|c|c|c|}\\hline\n    \\text{No.}&\\text{Prop}&\\text{Reason} \\\\\\hline\n    2.2.1. & \\neg P & \\unicode{x21af}\\text{Assumption}\\\\\n    2.2.2. & \\neg P\\lor\\neg Q & \\lor\\text{I},2.2.1\\\\\n    2.2.3. & \\begin{array}{c} \\\\\\neg(\\neg P\\lor\\neg Q)\\land \\\\ \\neg P\\lor\\neg Q\\end{array} & \\land\\text I, 2.1, 2.2.3. \\\\\\hline\n    \\end{array}\\\\\n  2.3. & Q & \\text{Similar to above.} \\\\ \\rowcolor{subtl}\n  2.4. & P\\land Q & \\land\\text{I}, 2.2, 2.3 \\\\\n  2.5. & (P\\land Q)\\land \\neg (P\\land Q) & \\land\\text I, 1., 2.4 \\\\\\hline\n  \\end{array}\\\\\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\nProof Exercises\n\n\n\nProve the following.\n\n\\(\\{\\neg(P\\to Q) \\}\\vdash P\\)\n\\(\\emptyset \\vdash P\\lor\\neg P\\)\n\\(\\{P\\land\\neg P\\}\\vdash \\alpha\\) for any proposition \\(\\alpha\\)\n\\(\\{P\\lor Q, P\\to R, Q\\to S\\}\\vdash R\\lor S\\)"
  },
  {
    "objectID": "prop_log/images/animations.html",
    "href": "prop_log/images/animations.html",
    "title": "How to Become a Mathematician",
    "section": "",
    "text": "Code\nfrom manim import *\nconfig.media_width = \"100%\"\n\n\n\n\nCode\n%%manim -qm -v WARNING LinePointParallel\n\nclass LinePointParallel(Scene):\n    def construct(self):\n        l = Line([7,9,0],[-5,-5,0])\n        self.play(Create(l))\n        p = Dot([2,-1,0], color=\"RED\")\n        self.play(Create(p))\n        self.wait(3)\n        l2 = Line([14,13,0],[-10,-15,0], color=\"BLUE\")\n        self.play(Create(l2))\n        self.wait(3)\n\n\n\nAnimation 0: Create(Line):   0%|          | 0/1 [00:00&lt;?, ?it/s]                                                                          \n\n\n\n      Your browser does not support the video element."
  },
  {
    "objectID": "prop_log/parse_tree.html",
    "href": "prop_log/parse_tree.html",
    "title": "Parse Trees",
    "section": "",
    "text": "The ambiguity between \\(\\neg(P\\lor Q)\\) and \\((\\neg P)\\lor Q\\) makes visible the need for the idea of a “parse tree”. To see what a parse tree is, let’s start with the example of the simpler proposition \\(P\\lor Q\\).\nCode\ngraph G {\n    v -- P;\n    v -- Q;\n}\n\n\n\n\n\n\nG\n\n\n\nv\n\nv\n\n\n\nP\n\nP\n\n\n\nv--P\n\n\n\n\nQ\n\nQ\n\n\n\nv--Q\nThis just expresses that the \\(\\lor\\) is “bound” directly to the sub-propositions \\(P\\) and \\(Q\\). More interesting is the parse tree for \\(\\neg(P\\lor Q)\\). I’ve produced it below – in a later version of this text I will try to properly typeset the \\(\\neg\\) symbol, but for now I merely use the dash, -, instead.\nCode\ngraph G {\n    \"-\" -- v\n    v -- P\n    v -- Q\n}\n\n\n\n\n\n\nG\n\n\n\n-\n\n-\n\n\n\nv\n\nv\n\n\n\n---v\n\n\n\n\nP\n\nP\n\n\n\nv--P\n\n\n\n\nQ\n\nQ\n\n\n\nv--Q\nThis illustrates that the symbol \\(\\neg\\) is applied to the entire formula \\(P\\lor Q\\), which itself is represented as a subtree of the parse tree."
  },
  {
    "objectID": "prop_log/parse_tree.html#representation",
    "href": "prop_log/parse_tree.html#representation",
    "title": "Parse Trees",
    "section": "Representation",
    "text": "Representation\nThis will first require us to make two decisions: How do we represent the input proposition, and how do we represent the output tree?\nThe input propositions will be represented by strings and lists. It’s easiest just to give some examples.\n\n\"P\" represents the propositional variable \\(P\\).\n[\"not\", \"P\"] represents \\(\\neg P\\).\n[[\"not\", \"P\"], \"or\", \"Q\"] represents \\((\\neg P)\\lor Q\\).\n\n\n\n\n\n\n\nProposition Representation\n\n\n\nGive the code representation of the propostion \\(\\neg(\\neg P)\\).\n\n\nThe output tree structure will be represented by classes. We will have a class PropVariable for propositional variables. This class will contain only a single piece of information, self.v, a string which is the name of the propositional variable.\nWe will have a Negation class which represents the negation of some other proposition. This will contain a single piece of information, self.neg, which is the tree structure of the proposition that is negated.\nThen we will have a Disjunction class which represents the disjunction of two propositions. It contains two pieces of information, self.left and self.right, representing the two disjuncts.\nIt will also be useful to have an abstract class Proposition which gives these three classes a common superclass.1\n\n\nCode\nclass Proposition:\n    pass\n\nclass PropVariable(Proposition):\n    def __init__(self, v):\n        assert (type(v) == str and len(v) == 1) \n        self.v = v\n    def __str__(self):\n        return(self.v)\n\nclass Negation(Proposition):\n    def __init__(self, beta):\n        assert issubclass(type(beta),Proposition)\n        self.neg = beta\n    def __str__(self):\n        return(\"(not \" + str(self.neg) + \")\")\n\nclass Disjunction(Proposition):\n    def __init__(self, beta, gamma):\n        assert issubclass(type(beta),Proposition) \\\n            and issubclass(type(gamma),Proposition)\n        self.left, self.right = beta, gamma\n    def __str__(self):\n        return(\"(\"+str(self.left)+\" or \" + str(self.right) + \")\")\n\n\n\n\n\n\n\n\nOther Op Classes\n\n\n\nWrite new classes in addition to the ones above, for conjunction, conditional, and biconditional propositions. (Hint: These are all almost exactly the same as Disjunction.)\n\n\n\n\n\n\n\n\nMake Proposition Instances\n\n\n\nThe following code makes instances of these classes and prints their string representations.\n\n\nCode\np = PropVariable(\"P\")\nnp = Negation(p)\nnpop = Disjunction(np,p)\n\nprint(str(p))\nprint(str(np))\nprint(str(npop))\n\n\nP\n(not P)\n((not P) or P)\n\n\nCreate an instance of these classes, which represents \\((\\neg Q)\\land (\\neg P)\\)."
  },
  {
    "objectID": "prop_log/parse_tree.html#structuring",
    "href": "prop_log/parse_tree.html#structuring",
    "title": "Parse Trees",
    "section": "Structuring",
    "text": "Structuring\nThe above was necessary to make the Python code work. But it was not the most interesting for the analysis of logic. The function below is the code that most reflects the idea of the parse tree. This takes a proposition, represented as we have described, and returns a tree structure, as we have defined with the Proposition class.\n\n\nCode\ndef parseTree(p):\n    \n    if type(p) == type(\"\"):\n        return PropVariable(p)\n    \n    if len(p) == 2:\n        assert( p[0] == \"not\" )\n        return Negation(parseTree(p[1]))\n    \n    if len(p) == 3:\n        if p[1] == \"or\": return Disjunction(parseTree(p[0]), parseTree(p[2]))\n        raise Exception(\"length 3 list but unrecognized middle token\")\n    raise Exception(\"length of list unrecognized\")\n\n\n\n\n\n\n\n\nExplain parseTree\n\n\n\nExplain the lines of code\n\n\nCode\nif type(p) == type(\"\"):\n    return PropVariable(p)\n\n\n\nExplain\n\n\nCode\nif len(p) == 2:\n    return Negation(pthelper(p[1]))\n\n\n(Note: I have omitted the “assertion”, since this is there mostly for debugging purposes – it is not especially interesting for the logic.)\n\nExplain\n\n\nCode\nif len(p) == 3:\n    if p[1] == \"or\": return Disjunction(pthelper(p[0]), pthelper(p[2]))\n\n\n\n\n\n\n\n\n\n\nOther parseTree Operations\n\n\n\nExtend the code of the parseTree function to make it parse conjunction, conditional, and biconditional propositions. For conjunction, use the “token” to be “and” rather than “or”. For biconditional, use the toke “iff” rather than “or”.\nFor the conditional, we will take its representation to be a little different. In order to represent \\(P\\to Q\\) we will represent this in code as [\"if\", \"P\", \"then\", \"Q\"]. Therefore the way that you will need to edit the code for the conditional is a bit different from the others."
  },
  {
    "objectID": "prop_log/parse_tree.html#parsing",
    "href": "prop_log/parse_tree.html#parsing",
    "title": "Parse Trees",
    "section": "Parsing",
    "text": "Parsing\nIt can be a little unsatisfying to input propositions in such an artificial way. Can’t we find a way to input a string like `“if (not P) then (Q or (R and S))” and the program will structure it and form the corresponding tree? Indeed it can be done and the code below accomplishes this!\nHowever, to understand it, you have to get a little familiar with the pyparsing library. Since none of this is very interesting for logic, I’ll just leave the code but won’t try to explain it.\n\n\nCode\nimport pyparsing\n\nterms = pyparsing.Word(pyparsing.alphas) | \"not\" | \"and\" | \"or\" | \"if\" | \"then\" | \"iff\" \nnesting = pyparsing.nestedExpr( '(', ')', content=terms)\n\ndef shape(s): \n    p = nesting.parseString(\"(\"+s+\")\")[0]\n    \n    return parseTree(p)"
  },
  {
    "objectID": "fol/pred.html#interpretation",
    "href": "fol/pred.html#interpretation",
    "title": "Predicate Logic",
    "section": "Interpretation",
    "text": "Interpretation\nWe analyzed the possibilities for propositional variables with variable evaluations, or equivalently, a truth-table. For a more expressive syntax, though, we should have a new way of assessing the expressions. Let’s first make an example language.\nConsider a language for natural numbers. To keep things simple, we will take a very small language with just three constant symbols, \\(a,b,c,d\\). These will be intended to refer to the numbers 1, 2, and 3.2 However, part of the job of the structure is to make this interpretation “official”. We will also have a two-place relation symbol L.\nNow that we know the language, we can talk about a structure for the language. We will write this structure as \\(\\mathcal S\\). To express that this \\(\\mathcal S\\) interprets \\(a\\) as the number \\(1\\), we will write \\(a^{\\mathcal S}\\) = 1. Likewise \\(b^{\\mathcal S}=2,c^{\\mathcal S}=3,d^{\\mathcal S}=3\\) express the interpretation of \\(b\\) as \\(2\\) and \\(c\\) and \\(d\\) as \\(3\\). \\(\\mathcal S\\) also interprets the symbol \\(L\\) as the less-than relation. It is common to express this last fact by the following set equality.\n\\[\nL^{\\mathcal S} = \\{(1,2),(1,3),(2,3)\\}\n\\]\nIf you’ve never seen this before it’s likely confusing. What this says is that \\((1,2)\\) is in the relation, that is to say, \\((1,2)\\in L^{\\mathcal S}\\). And what this means is that 1 is related to 2.\nContinuing likewise, it says that 1 relates to 3 and 2 relates to 3. In total, this expresses the less-than relation among the numbers 1, 2, and 3!\n\n\n\n\n\n\nLove Triangle Relation\n\n\n\nUsing the same language as above, write down a structure which interprets \\(a\\) as the person named Adam, \\(b\\) is Becky, \\(c\\) is Carla, \\(d\\) is Dale, and \\(L\\) is the “loves” relation. Write down a structure which corresponds to: Adam loves Becky, Becky loves Carla, Carla loves nobody, and Dale loves everybody.\n\n\nIf we added to the example above, a predicate \\(E\\) meant to represent the even numbers, then we would have \\(E^{\\mathcal S}=\\{2\\}\\). This shows that, for a predicate, its interpretation is the set of elements which have the property.\nNow because we are able to talk about objects, it will be useful to introduce a new symbol into our language: The equality symbol. This will allow us to write, for example, the propositions \\(c=d\\) and \\(a\\ne b\\), both of which are true in this particular structure (but not in the structure described in the exercise above, “Love Triangle Relation”)."
  },
  {
    "objectID": "fol/pred.html#evaluation",
    "href": "fol/pred.html#evaluation",
    "title": "Predicate Logic",
    "section": "Evaluation",
    "text": "Evaluation\nNow a structure should not merely interpret. It should also evaluate, which is to say, tell us whether a given proposition is true or false. If we take the example above, whereby\n\\[\na^{\\mathcal S}=1,b^{\\mathcal S}=2,c^{\\mathcal S}=3,L^{\\mathcal S}=\\{(1,2),(1,3),(2,3)\\}\n\\]\nthen we should have that \\((L(a,b))^{\\mathcal S}=T\\) since \\(a\\) denotes 1 and \\(b\\) denotes 2, and \\(L\\) is the less-than relation. Since 1 and 2 stand in the less-than relation, this proposition is true. On the other hand, we should have \\((L(b,a))^{\\mathcal S}=F\\).\nThe technical definition of the evaluation of a simple proposition of a two-place relation is: Let \\(R\\) be any two-place relation symbol and \\(a,b\\) any two constant symbols in the language. Then \\((R(a,b))^{\\mathcal S} = T\\) if and only if \\((a^{\\mathcal S},b^{\\mathcal S})\\in R^{\\mathcal S}\\).\nIt may help to see this definition “in action”. In the example above, \\((L(a,b))^{\\mathcal S}=T\\) because \\((a^{\\mathcal S},b^{\\mathcal S}) = (1,2)\\) and also \\(L^{\\mathcal S}=\\{(1,2),(1,3),(2,3)\\}\\). Therefore we do have the relation \\((a^{\\mathcal S},b^{\\mathcal S})\\in L^{\\mathcal S}\\) which is why we can evaluate\n\\[\n(L(a,b))^{\\mathcal S}=T\n\\]\nOn the other hand \\((L(b,a))^{\\mathcal S}=F\\) because \\((b^{\\mathcal S},a^{\\mathcal S})=(2,1)\\not\\in L^{\\mathcal S}\\).\n\n\n\n\n\n\nLove Triangle Evaluation\n\n\n\nUsing again the structure that you used in the previous exercise “Love Triangle Relation”, decide whether the following propositions are true.\n\\[\nL(a,b),\\quad L(b,a),\\quad L(c,d)\\to\\neg L(d,c)\n\\]\n\n\nOf course we have a simple rule for evaluating equality. If \\(a,b\\) are any two constant symbols then \\((a=b)^{\\mathcal S}=T\\) if and only if \\(a^{\\mathcal S}=b^{\\mathcal S}\\)."
  }
]