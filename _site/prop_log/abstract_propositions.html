<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.241">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Mathematical Reasoning 2023 - Abstract Propositions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Mathematical Reasoning 2023</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-prop.-logic" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Prop. Logic</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-prop.-logic">    
        <li>
    <a class="dropdown-item" href="../prop_log/ancient_greek.html" rel="" target="">
 <span class="dropdown-text">Ancient Greece</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../prop_log/core_examples.html" rel="" target="">
 <span class="dropdown-text">Two Examples</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../prop_log/abstract_propositions.html" rel="" target="">
 <span class="dropdown-text">Abstract Propositions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../prop_log/parse_tree.html" rel="" target="">
 <span class="dropdown-text">Parse Trees</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../prop_log/eval.html" rel="" target="">
 <span class="dropdown-text">Propositional Evaluation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../prop_log/op_props.html" rel="" target="">
 <span class="dropdown-text">Semantic Properties</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../prop_log/deduction.html" rel="" target="">
 <span class="dropdown-text">Deduction</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../prop_log/axiom_systems.html" rel="" target="">
 <span class="dropdown-text">Axiom Systems</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-fol" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">FOL</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-fol">    
        <li>
    <a class="dropdown-item" href="../fol/pred.html" rel="" target="">
 <span class="dropdown-text">Predicate Logic</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-arithmetic" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Arithmetic</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-arithmetic">    
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-geometry" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Geometry</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-geometry">    
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-reals" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Reals</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-reals">    
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-combinatorics" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Combinatorics</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-combinatorics">    
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-set-theory" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Set Theory</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-set-theory">    
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../prop_log/abstract_propositions.html">Abstract Propositions</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/ancient_greek.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Ancient Greece</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/core_examples.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Two Examples</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/abstract_propositions.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Abstract Propositions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/parse_tree.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Parse Trees</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/eval.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Propositional Evaluation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/op_props.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Semantic Properties</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/deduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Deduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../prop_log/axiom_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Axiom Systems</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="3">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#propositional-variables" id="toc-propositional-variables" class="nav-link active" data-scroll-target="#propositional-variables">Propositional Variables</a></li>
  <li><a href="#truth-functional-connectives" id="toc-truth-functional-connectives" class="nav-link" data-scroll-target="#truth-functional-connectives">Truth-functional Connectives</a>
  <ul class="collapse">
  <li><a href="#negation" id="toc-negation" class="nav-link" data-scroll-target="#negation">Negation</a></li>
  <li><a href="#disjunction" id="toc-disjunction" class="nav-link" data-scroll-target="#disjunction">Disjunction</a></li>
  <li><a href="#conjunction" id="toc-conjunction" class="nav-link" data-scroll-target="#conjunction">Conjunction</a></li>
  <li><a href="#the-conditional" id="toc-the-conditional" class="nav-link" data-scroll-target="#the-conditional">The Conditional</a></li>
  <li><a href="#biconditional" id="toc-biconditional" class="nav-link" data-scroll-target="#biconditional">Biconditional</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Abstract Propositions</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>

<p>We looked at two examples of arguments in the previous section, but we don’t want to be too focused on specific cases. Eventually we want to analyze logic itself, so that it can be applied to any propositions that may come up.</p>
<section id="propositional-variables" class="level1">
<h1>Propositional Variables</h1>
<p>We will write an abstract proposition with a variable, like <span class="math inline">\(P\)</span>. What this means is that <span class="math inline">\(P\)</span> could be any proposition, and we don’t know which it is. So for instance <span class="math inline">\(P\)</span> could represent <span class="math inline">\(x=1\)</span> or “Russia is large”, or any other assertion that could be true or false.</p>
<p>Because we don’t know whether an abstract proposition is true or false, we represent this in a table. In the table below, naturally we use <span class="math inline">\(T\)</span> to denote “true” and <span class="math inline">\(F\)</span> to denote “false”.</p>
<p><span class="math display">\[
\begin{array}{|c|} \hline
P \\ \hline
T \\ \hline
F \\ \hline
\end{array}
\]</span></p>
<p>For now, the table may seem like making too big a deal over a small thing. As the abstract propositions get more complex, though, the tables will help us to manage that complexity. So if this doesn’t make sense right now, don’t worry too much about it. As you see the table really do its job in the next few subsections, it will make more sense.</p>
</section>
<section id="truth-functional-connectives" class="level1">
<h1>Truth-functional Connectives</h1>
<p>A propositional variable by itself is boring. The way that we will analyze arguments is by breaking it into its component sentences. These sentences are themselves formed by joining together simpler sentences. Take for instance</p>
<blockquote class="blockquote">
<p>Either <span class="math inline">\(x=1\)</span> or <span class="math inline">\(x\ne 1\)</span>.</p>
</blockquote>
<p>Align the sentence <span class="math inline">\(x=1\)</span> with the propositional variable <span class="math inline">\(P\)</span>, and <span class="math inline">\(x\ne 1\)</span> with the sentence <span class="math inline">\(Q\)</span>. Then the sentence in the quote-block above is “<span class="math inline">\(P\)</span> or <span class="math inline">\(Q\)</span>”. This is an example of a sentence which is formed by joining together simpler sentences.</p>
<section id="negation" class="level2">
<h2 class="anchored" data-anchor-id="negation">Negation</h2>
<p>One way to form a new proposition from the variable <span class="math inline">\(P\)</span> is to negate it. If the proposition <span class="math inline">\(P\)</span> is aligned with <span class="math inline">\(x=1\)</span> then its negation is “<span class="math inline">\(x\)</span> is not equal to 1”, or in more standard mathematical notation, <span class="math inline">\(x\ne 1\)</span>. This flips the truth-value of the proposition being negated.</p>
<p>To represent the negation of <span class="math inline">\(P\)</span> we write <span class="math inline">\(\neg P\)</span>.</p>
<p>Below is the truth-table for negation.</p>
<p><span class="math display">\[
\begin{array}{|c||c|} \hline
\columncolor{lightgray}\rowcolor{lightgray}P &amp; \neg  P \\ \hline \\\hline
T &amp; \color{red}F  \\ \hline
F &amp; \color{red}T  \\ \hline
\end{array}
\]</span></p>
<p>Now that the table is getting sophisticated, I’m adding some extra features. First of all, I’ve shaed the first row and column with a gray background. This is to indicate that the first row is a header row. Also the first column as a kind of header column, because we will just use it to “index” the entries in the body of the truth table.</p>
<p>The first “real” content of the table is emphasized below.</p>
<p><span class="math display">\[
\begin{array}{|c||c|} \hline
\columncolor{lightgray}\rowcolor{lightgray}P &amp; \neg  P \\ \hline \\\hline
T &amp; \bf \color{red}F  \\ \hline
F &amp; \color{red}T  \\ \hline
\end{array}
\]</span></p>
<p>This is computed by first finding the value <span class="math inline">\(P\)</span>, which is <span class="math inline">\(T\)</span> on this row. Then we apply the <span class="math inline">\(\neg\)</span> operation to it, flipping it to <span class="math inline">\(F\)</span> and hence this is the value. The second row of truth-values is computed similarly.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Double Negation">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Double Negation
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Make the truth-table for <span class="math inline">\(\neg (\neg P)\)</span>.</p>
<p>We say that two propositions are <strong>equivalent</strong> if they “have the same truth-table”.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Are <span class="math inline">\(P\)</span> and <span class="math inline">\(\neg(\neg P)\)</span> equivalent?</p>
</div>
</div>
<hr>
<p>Negation is also represented in almost every programming language. Below we can see how Python represents truth values, and then see how Python gives the ability to negate them.</p>
<div id="3cfc9ec5" class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="kw">not</span> <span class="va">True</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="kw">not</span> <span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>False
True</code></pre>
</div>
</div>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="DN in Python">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
DN in Python
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Demonstrate double-negation (i.e.&nbsp;the equivalence of <span class="math inline">\(P\)</span> and <span class="math inline">\(\neg(\neg P)\)</span>) in a Python program.</p>
</div>
</div>
</section>
<section id="disjunction" class="level2">
<h2 class="anchored" data-anchor-id="disjunction">Disjunction</h2>
<p>If <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are any two propositional variables, then to express “<span class="math inline">\(P\)</span> or <span class="math inline">\(Q\)</span>” we write <span class="math inline">\(P\lor Q\)</span>. Note that by saying that either sentence is true, it is enough if just one of them is true. Take for example the sentence “Either the prize is behind the first door or the second door.” If the prize is behind the first door, then that sentence was true. But if the prize was behind the third door (i.e.&nbsp;not the first and not the second), the sentence was false.</p>
<p>This is called the <strong>disjunction</strong> of <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>, and it has the following truth-table.</p>
<p><span class="math display">\[
\begin{array}{|c|c|ccc|}\hline
\columncolor{lightgray}\rowcolor{lightgray}P&amp;Q\columncolor{lightgray}&amp;P&amp;\lor &amp;Q\\\hline&amp;&amp;&amp;&amp;\\\hline
T&amp;T&amp;&amp;\color{red}T&amp;\\\hline
T&amp;F&amp;&amp;\color{red}T&amp;\\\hline
F&amp;T&amp;&amp;\color{red}T&amp;\\\hline
F&amp;F&amp;&amp;\color{red}F&amp;\\\hline
\end{array}
\]</span></p>
<p>Note that this time the table has four rows (not counting the header row which declares the variables and proposition). This is because there are more possibilities with two variables than with just one. We could have both <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> true, which is the first row – or we could have one true and the other false, which is the next two rows – or both could be false, which is the final row.</p>
<p>In Python we can model this with the disjunction operator.</p>
<div id="43090395" class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="va">True</span> <span class="kw">or</span> <span class="va">True</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="va">True</span> <span class="kw">or</span> <span class="va">False</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="va">False</span> <span class="kw">or</span> <span class="va">True</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="va">False</span> <span class="kw">or</span> <span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>True
True
True
False</code></pre>
</div>
</div>
<p>In fact, the above can be done more simply in a couple of “embedded for-loops”, as shown below.</p>
<div id="f242fd10" class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>truth_values <span class="op">=</span> [<span class="va">True</span>, <span class="va">False</span>] <span class="co"># A list of all truth values</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> P <span class="kw">in</span> truth_values: <span class="co"># Iterate through all truth values</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Q <span class="kw">in</span> truth_values: <span class="co"># Q does likewise</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(P <span class="kw">or</span> Q) <span class="co"># Compute "their 'or'" and print it.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>True
True
True
False</code></pre>
</div>
</div>
<p>The way that the above code works is: <code>P</code> is a variable, and it will eventually “take” every value from the list <code>[True,False]</code>. Initially it takes the value <code>True</code>.</p>
<p>After <code>P</code> takes <code>True</code> then the code inside, <code>for Q in [True,False]: print(P or Q)</code> executes. But the way that this executes is, similarly, that <code>Q</code> starts by taking the value <code>True</code>. Then the program executes <code>print(P or Q)</code> which is effectively equivalent to <code>print(True or True)</code>.</p>
<p>Making a long story short, on the next loop iteration, <code>P</code> is still true but <code>Q</code> takes the value <code>False</code>. Then <code>print(P or Q)</code> executes, which is equivalent to <code>print(True or False)</code>. Then <code>P</code> ticks over to <code>False</code> and <code>Q</code> starts over at <code>True</code>, and <code>print(P or Q)</code> is equivalent to <code>print(False or True)</code>. Then <code>P</code> is <code>False</code> and <code>Q</code> takes <code>True</code>, and <code>print(P or Q)</code> is equivalent to <code>print(False or False)</code>.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Not Loop">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Not Loop
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>This code:</p>
<div id="e0632b37" class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="kw">not</span> <span class="va">True</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="kw">not</span> <span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>False
True</code></pre>
</div>
</div>
<p>could instead be implemented with a for-loop. Fill in the parts of the following code where it contains <code>%TODO</code> so that it does the same thing as the code above.</p>
<div id="e378c2f2" class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> P <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"\%TODO"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
<hr>
<p>If we use three variables, we can analyze the sentence <span class="math inline">\(P\lor (Q\lor R)\)</span>. This now requires even more rows of truth-values. How many more?</p>
<p>Well it should <em>double</em> the number of rows, from how many were needed for two variables. That is because we need to consider two possibilities: Either <span class="math inline">\(P\)</span> is true or it is false. If <span class="math inline">\(P\)</span> is true, then we need to run through all of the remaining four possibilities for <span class="math inline">\(Q\)</span> and <span class="math inline">\(R\)</span>. So this half of the truth-table should look like:</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|} \hline
P&amp;Q&amp;R\\\hline\\\hline
T&amp;T&amp;T\\\hline
T&amp;T&amp;F\\\hline
T&amp;F&amp;T\\\hline
T&amp;F&amp;F\\\hline
\end{array}
\]</span></p>
<p>Then it’s clear what we do for the other half, where <span class="math inline">\(P\)</span> is <span class="math inline">\(F\)</span>.</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|} \hline
P&amp;Q&amp;R\\\hline\\\hline
F&amp;T&amp;T\\\hline
F&amp;T&amp;F\\\hline
F&amp;F&amp;T\\\hline
F&amp;F&amp;F\\\hline
\end{array}
\]</span></p>
<p>Putting these together we get the eight-row truth-table</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|} \hline
P&amp;Q&amp;R\\\hline\\\hline
T&amp;T&amp;T\\\hline
T&amp;T&amp;F\\\hline
T&amp;F&amp;T\\\hline
T&amp;F&amp;F\\\hline
F&amp;T&amp;T\\\hline
F&amp;T&amp;F\\\hline
F&amp;F&amp;T\\\hline
F&amp;F&amp;F\\\hline
\end{array}
\]</span></p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="General Row Numbers">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
General Row Numbers
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>If there were 4 variables, how many rows would be needed? (Hint: One variable required two rows. Two variables, four rows; three variables, eight row; …)</p>
<p>If there were <span class="math inline">\(n\)</span> variables, how many rows would be needed?</p>
</div>
</div>
<p>Now that we know the column and row “headers” we can fill in the table for <span class="math inline">\(P\lor Q\lor R\)</span>. However, doing it all at once can be difficult to parse, so let’s do this in stages. First let’s merely populate the columns under the variables – this is a tedious transcription.</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\columncolor{lightgray}\rowcolor{lightgray}P&amp;\columncolor{lightgray}Q&amp;\columncolor{lightgray}R&amp;&amp;P&amp;\lor &amp;(Q&amp;\lor &amp;R)\\\hline&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\hline
T&amp;T&amp;T &amp;&amp; T &amp;  &amp; T &amp;  &amp; T\\\hline
T&amp;T&amp;F &amp;&amp; T &amp;  &amp; T &amp;  &amp; F\\\hline
T&amp;F&amp;T &amp;&amp; T &amp;  &amp; F &amp;  &amp; T\\\hline
T&amp;F&amp;F &amp;&amp; T &amp;  &amp; F &amp;  &amp; F\\\hline
F&amp;T&amp;T &amp;&amp; F &amp;  &amp; T &amp;  &amp; T\\\hline
F&amp;T&amp;F &amp;&amp; F &amp;  &amp; T &amp;  &amp; F\\\hline
F&amp;F&amp;T &amp;&amp; F &amp;  &amp; F &amp;  &amp; T\\\hline
F&amp;F&amp;F &amp;&amp; F &amp;  &amp; F &amp;  &amp; F\\\hline
\end{array}
\]</span></p>
<p>Now we try to fill in the values under any operators. However, if we look at the first <span class="math inline">\(\lor\)</span> operator, we cannot fill it in! This is because it must “read” the value to its left and right. The values to the left are there, but the values to the right come from everything inside <span class="math inline">\((Q\lor R)\)</span>. These values should be read from what appears under the <span class="math inline">\(\lor\)</span> and they are blank. Therefore we must fill these in first.</p>
<p>To fill in the values under <span class="math inline">\((Q\lor R)\)</span>, we get the following table. Notice that the first row is computed as <span class="math inline">\(T\lor T=T\)</span>. The second is <span class="math inline">\(T\lor F=T\)</span> and the third is <span class="math inline">\(F\lor T = T\)</span> and the fourth is <span class="math inline">\(F\lor F=F\)</span>, and so on. Because this column of computation is derived from others, I will color it.</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\columncolor{lightgray}\rowcolor{lightgray}P&amp;\columncolor{lightgray}Q&amp;\columncolor{lightgray}R&amp;&amp;P&amp;\lor &amp;(Q&amp;\lor &amp;R)\\\hline &amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\hline
T&amp;T&amp;T &amp;&amp; T &amp;  &amp; T &amp; \color{blue}T &amp; T\\\hline
T&amp;T&amp;F &amp;&amp; T &amp;  &amp; T &amp; \color{blue}T &amp; F\\\hline
T&amp;F&amp;T &amp;&amp; T &amp;  &amp; F &amp; \color{blue}T &amp; T\\\hline
T&amp;F&amp;F &amp;&amp; T &amp;  &amp; F &amp; \color{blue}F &amp; F\\\hline
F&amp;T&amp;T &amp;&amp; F &amp;  &amp; T &amp; \color{blue}T &amp; T\\\hline
F&amp;T&amp;F &amp;&amp; F &amp;  &amp; T &amp; \color{blue}T &amp; F\\\hline
F&amp;F&amp;T &amp;&amp; F &amp;  &amp; F &amp; \color{blue}T &amp; T\\\hline
F&amp;F&amp;F &amp;&amp; F &amp;  &amp; F &amp; \color{blue}F &amp; F\\\hline
\end{array}
\]</span></p>
<p>And now that this column has been populated, the column under the first <span class="math inline">\(\lor\)</span> now “sees” all the values that it needs to compute. Therefore we do this in the table below. Note that the first row is computed as <span class="math inline">\(T\lor{\color{blue} T}=\color{red}T\)</span>, and the fourth row is computed as <span class="math inline">\(T\lor {\color{blue} F}=\color{red} T\)</span>, for two illustrations.</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\columncolor{lightgray}\rowcolor{lightgray}P&amp;\columncolor{lightgray}Q&amp;\columncolor{lightgray}R&amp;&amp;P&amp;\lor &amp;(Q&amp;\lor &amp;R)\\\hline&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\hline
T&amp;T&amp;T &amp;&amp; T &amp; \color{red}T &amp; T &amp; \color{blue}T &amp; T\\\hline
T&amp;T&amp;F &amp;&amp; T &amp; \color{red}T &amp; T &amp; \color{blue}T &amp; F\\\hline
T&amp;F&amp;T &amp;&amp; T &amp; \color{red}T &amp; F &amp; \color{blue}T &amp; T\\\hline
T&amp;F&amp;F &amp;&amp; T &amp; \color{red}T &amp; F &amp; \color{blue}F &amp; F\\\hline
F&amp;T&amp;T &amp;&amp; F &amp; \color{red}T &amp; T &amp; \color{blue}T &amp; T\\\hline
F&amp;T&amp;F &amp;&amp; F &amp; \color{red}T &amp; T &amp; \color{blue}T &amp; F\\\hline
F&amp;F&amp;T &amp;&amp; F &amp; \color{red}T &amp; F &amp; \color{blue}T &amp; T\\\hline
F&amp;F&amp;F &amp;&amp; F &amp; \color{red}F &amp; F &amp; \color{blue}F &amp; F\\\hline
\end{array}
\]</span></p>
<p>As usual, the truth-table of the proposition is highlighted in red.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Python Triple Disjunction">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Python Triple Disjunction
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Demonstrate a couple of rows of the truth-table above in some Python code. For instance, run stuff like <code>True or (False or False)</code>.</p>
</div>
</div>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Finite Disjunction">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Finite Disjunction
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>The following Python code computes the truth-table for <span class="math inline">\(P\lor(Q\lor R)\)</span>.</p>
<div id="bce71685" class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> P <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Q <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> R <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(P <span class="kw">or</span> (Q <span class="kw">or</span> R))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>True
True
True
True
True
True
True
False</code></pre>
</div>
</div>
<p>Write Python code to compute the truth-table for <span class="math inline">\(P\lor(Q\lor (R\lor S))\)</span>.</p>
<p>When you have, note that the only row at which the table is false, is the last row.</p>
<hr>
<p>In general, a disjunction of <span class="math inline">\(n\)</span> variables will be true if how many of the variables take the value <span class="math inline">\(T\)</span>?</p>
</div>
</div>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Disjunction Associativity">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Disjunction Associativity
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>I claim that <span class="math inline">\(P\lor (Q\lor R)\)</span> is equivalent to <span class="math inline">\((P\lor Q)\lor R\)</span>. Write a Python program to prove that this is true.</p>
<p>This fact is called the <strong>associativity</strong> of disjunction.</p>
<hr>
<p>I also claim that disjunction is <strong>commutative</strong> which means <span class="math inline">\(P\lor Q\)</span> is equivalent to <span class="math inline">\(Q\lor P\)</span>. Write a Python program to prove whether this is true.</p>
</div>
</div>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Parsing Ambiguity">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Parsing Ambiguity
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Make a truth table for both <span class="math inline">\(\neg (P\lor Q)\)</span> and <span class="math inline">\((\neg P)\lor Q\)</span>, and check your answers with the following Python code.</p>
<div id="d61aff0e" class="cell" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> P <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Q <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="kw">not</span> (P <span class="kw">or</span> Q))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>() <span class="co"># Just print a blank line to help see the separation of the two tables.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> P <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Q <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>((<span class="kw">not</span> P) <span class="kw">or</span> Q)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>False
False
False
True

True
False
True
True</code></pre>
</div>
</div>
<p>Then use these two truth-tables to argue that these two propositions are <strong>not</strong> equivalent.</p>
<p>Use the above result to argue that <span class="math inline">\(\neg P\lor Q\)</span> is meaningless.</p>
<p>However, although <span class="math inline">\(\neg P\lor Q\)</span> is technically meaningless, we will in fact assume that if we ever write <span class="math inline">\(\neg P\lor Q\)</span> it is actually short-hand for <span class="math inline">\((\neg P)\lor Q\)</span>. The more general rule is that</p>
<blockquote class="blockquote">
<p>Negation takes precedence.</p>
</blockquote>
<p>That is to say, in any abstract logical expression in which negation occurs, we will assume that it applies <em>first</em>.</p>
<hr>
<p>Also, technically <span class="math inline">\(P\lor Q\lor R\)</span> is meaningless because we technically require parentheses to distinguish between <span class="math inline">\(P\lor (Q\lor R)\)</span> and <span class="math inline">\((P\lor Q)\lor R\)</span>.</p>
<p>However, since we have seen that these are equivalent, in fact the ambiguity is unimportant. We will therefore feel free to write down <span class="math inline">\(P\lor Q\lor R\)</span> and the reader is free to decide for themselves whether this means <span class="math inline">\(P\lor (Q\lor R)\)</span> or <span class="math inline">\((P\lor Q)\lor R\)</span> – whichever one the reader likes best!</p>
</div>
</div>
</section>
<section id="conjunction" class="level2">
<h2 class="anchored" data-anchor-id="conjunction">Conjunction</h2>
<p>Having done all that work for disjunction, conjunction is mostly trivial. It represents the proposition “<span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>”, we write this symbolically as <span class="math inline">\(P\land Q\)</span>, and it has the following truth-table.</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|c|c|c|}\hline
\columncolor{lightgray}\rowcolor{lightgray}P&amp;\columncolor{lightgray}Q&amp;&amp;P&amp;\land &amp;Q\\\hline &amp;&amp;&amp;&amp;&amp;\\\hline
T&amp;T&amp;&amp;T&amp;\color{red}T&amp;T\\\hline
T&amp;F&amp;&amp;T&amp;\color{red}F&amp;F\\\hline
F&amp;T&amp;&amp;F&amp;\color{red}F&amp;T\\\hline
F&amp;F&amp;&amp;F&amp;\color{red}F&amp;F\\\hline
\end{array}
\]</span></p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Conjunction Catchall">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Conjunction Catchall
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Re-do all the exercises for disjunction but this time for conjunction, noting any interesting dissimilarities.</p>
</div>
</div>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Distribution">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Distribution
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Show (either in a table or a program) that <span class="math inline">\(P\land (Q\lor R)\)</span> is <strong>not</strong> equivalent to <span class="math inline">\((P\land Q)\lor R\)</span> and conclude that “conjunction and disjunction do not associate”.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>However, show that <span class="math inline">\(P\land (Q\lor R)\)</span> is equivalent to <span class="math inline">\((P\land Q) \lor (P\land R)\)</span>. Also, come up with a corresponding equivalence for <span class="math inline">\(P\lor (Q\land R)\)</span> and prove that it’s equivalent.</p>
<p>The above is called the <strong>distribution</strong> of <span class="math inline">\(\land\)</span> over <span class="math inline">\(\lor\)</span> (and conversely). This is similar to how multiplication distributes over addition.</p>
<p><span class="math display">\[
x(y+z) = xy+xz
\]</span></p>
<p>However, note that addition does <strong>not</strong> distribute over multiplication.</p>
<p><span class="math display">\[
x+yz \ne (x+y)(x+z)
\]</span></p>
<p>Therefore these logical operators are “more distributive” than the mathematical operators. Each distributes over the other, whereas in mathematics, it is only that multiplication distributes over addition.</p>
</div>
</div>
</section>
<section id="the-conditional" class="level2">
<h2 class="anchored" data-anchor-id="the-conditional">The Conditional</h2>
<p>The conditional is, in a sense, no different from the other logical symbols. It is meant to represent propositions of the form “If <span class="math inline">\(P\)</span> then <span class="math inline">\(Q\)</span>.” It has symbol <span class="math inline">\(\to\)</span> and truth-table</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|c|c|c|}\hline
\columncolor{lightgray}\rowcolor{lightgray}P&amp;\columncolor{lightgray}Q&amp;&amp;P&amp;\to &amp;Q\\\hline&amp;&amp;&amp;&amp;\\\hline
T&amp;T&amp;&amp;T&amp;\color{red}T&amp;T\\\hline
T&amp;F&amp;&amp;T&amp;\color{red}F&amp;F\\\hline
F&amp;T&amp;&amp;F&amp;\color{red}T&amp;T\\\hline
F&amp;F&amp;&amp;F&amp;\color{red}T&amp;F\\\hline
\end{array}
\]</span></p>
<p>However, this truth-table is probably perplexing. Let’s try to see the correspondence between a sentence of the form “If <span class="math inline">\(P\)</span> then <span class="math inline">\(Q\)</span>.” and this truth-table. Consider these four examples:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled" title="If Then Example">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
If Then Example
</div>
</div>
<div class="callout-body-container callout-body">
<p>Example:</p>
<p>If the sun is out, then the weather is warm.</p>
</div>
</div>
<p>Now consider each of the four possibilities. The first is that the sun is out and the weather is warm. Well, it makes sense that the sentence was true in this case. This explains the first row, since we aligned <span class="math inline">\(P\)</span> with a true sentence, <span class="math inline">\(Q\)</span> with a true sentence, and the result is a true sentence.</p>
<p>Next consider the possibility that the sun is out, but because you live in the South Pole, the weather is cold. In this case, the sentence was false. This explains the second row since <span class="math inline">\(P\)</span> is true and <span class="math inline">\(Q\)</span> false.</p>
<p>So far I think everything makes pretty immediate sense, but the next two possibilities are the ones that most people struggle with the most. What is especially difficult about them is that <span class="math inline">\(P\)</span> is false. A sentence of the form “If <span class="math inline">\(P\)</span> then <span class="math inline">\(Q\)</span>.” is quite literally predicated upon the assumption of <span class="math inline">\(P\)</span>, so it becomes quite difficult to think about what one should say if <span class="math inline">\(P\)</span> is false.</p>
<p>In the table, it is clear that we have decided that, when <span class="math inline">\(P\)</span> is false, the conditional sentence is true (regardless of the truth-value of <span class="math inline">\(Q\)</span>). You can imagine that it behaves like a promise: “I promise that, IF the sun is out, then the weather is warm.” When the condition of the promise is removed, because say the sun is not out, then the promise is so-to-speak nullified – and we say that the speaker was speaking the truth.</p>
<p>In the example of the sun and the weather, imagine the “false-true” case in which the sun is not out but the weather is still warm. In that case, we regard the speaker as not wrong, because the condition of the sentence was not met. And similarly, in the false-false case whether the sun is not out and the weather is not warm, again the speaker is still speaking the truth.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Conditional Properties">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Conditional Properties
</div>
</div>
<div class="callout-body-container callout-body">
<p>Show that the conditional is neither associative nor commutative.</p>
</div>
</div>
<div class="callout callout-style-simple callout-note no-icon callout-titled" title="Antecedent and Consequent">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Antecedent and Consequent
</div>
</div>
<div class="callout-body-container callout-body">
<p>Because the conditional is not commutative, it now makes sense to have vocabulary for talking about the left- and right-side of the <span class="math inline">\(\to\)</span> symbol. If <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are any two propositions<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> then for the conditional proposition <span class="math inline">\(\alpha\to\beta\)</span> we call <span class="math inline">\(\alpha\)</span> the <strong>antecedent</strong> and <span class="math inline">\(\beta\)</span> the <strong>consequent</strong>.</p>
<p>For disjunction and conjunction such a distinction makes no sense, but it will still be worthwhile to have vocabulary to talk about the component sentences. So for instance, in the conjunction proposition <span class="math inline">\(\alpha\land\beta\)</span>, we call <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> the <strong>conjuncts</strong> of the conjunction. We also call them the <strong>disjuncts</strong> of the disjunction <span class="math inline">\(\alpha\lor\beta\)</span>.</p>
</div>
</div>
<p>Besides having the most confusing truth-table, the conditional also is the hardest to translate to and from natural language. Of course if we say “If a polygon has three angles then it is a triangle,” then we would align <span class="math inline">\(P\)</span> with the sentence “the polygon has three angles” and <span class="math inline">\(Q\)</span> with “the polygon is a triangle”. The the entire proposition is aligned with <span class="math inline">\(P\to Q\)</span>.</p>
<p>However, the first clause is not always the one that goes to the left of the <span class="math inline">\(\to\)</span>. The example sentence is equivalent to “The polygon is a triangle if it has three angles.” This makes it seem as though the clause after the word “if” will always appear to the left of the <span class="math inline">\(\to\)</span>.</p>
<p>However, even this is not true! The sentence “The polygon is a triangle only if it has three angles” is equivalent to “If the polygon is a triangle then it has three angles”! This one is often especially confusing to a new student, learning about the conditional.</p>
<p>To help make the “only if” construction clearer, imagine a castle which is only accessible by a bridge, which is guarded by a knight.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\_site/prop_log\images\knight.png" class="img-fluid figure-img" width="204"></p>
</figure>
</div>
<p>Then the sentence “You can enter the castle only if you take the bridge” can be stated as the if-then sentence</p>
<blockquote class="blockquote">
<p>If you are in the castle then you took the bridge.</p>
</blockquote>
<p>Note that the reverse is not true: If you take the bridge, you might not enter the castle – the knight might still stab you in the head and you’ll never make it to the castle!</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Only If">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Only If
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Let <span class="math inline">\(P\)</span> be the proposition “<span class="math inline">\(x+1 = 2\)</span>” and let <span class="math inline">\(Q\)</span> be the proposition “<span class="math inline">\(x=1\)</span>”. Is the proposition “<span class="math inline">\(x+1=2\)</span> only if <span class="math inline">\(x=1\)</span>” the same as <span class="math inline">\(P\to Q\)</span> or <span class="math inline">\(Q\to P\)</span>?</p>
</div>
</div>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Only If">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Only If
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Go back to the two examples in the previous section (<a href="core_examples.html">link here</a>) and identify all instances of if-then sentences.</p>
</div>
</div>
</section>
<section id="biconditional" class="level2">
<h2 class="anchored" data-anchor-id="biconditional">Biconditional</h2>
<p>Because it comes up so often, we will use the symbol <span class="math inline">\(\leftrightarrow\)</span> as an abbreviation for <span class="math inline">\((P\to Q) \land (Q\to P)\)</span>. It is often represented in English by a sentence of the form “<span class="math inline">\(P\)</span> if and only if <span class="math inline">\(Q\)</span>”. This form doesn’t come up extremely often in natural scenarios, but it comes up in mathematics everywhere.</p>
<div class="callout callout-style-simple callout-important no-icon callout-titled" title="Biconditional Truth Table">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Biconditional Truth Table
</div>
</div>
<div class="callout-body-container callout-body">
<p>Exercise:</p>
<p>Produce the truth-table for <span class="math inline">\(P\leftrightarrow Q\)</span>, and show that <span class="math inline">\(\leftrightarrow\)</span> is both commutative and associative.</p>
</div>
</div>


</section>
</section>


<div id="quarto-appendix" class="default"><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Having the same truth-table means: They have the same truth-value at every row of the table.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>It may take an act of interpretation to know exactly what is being asked here. But to say that “conjunction and disjunction do not associate”, means that if an expression has both symbols, then you cannot merely switch around the parentheses.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The entire topic of the conditional is, in fact, a giant philosophical mess. There has been an enormous literature in linguistics and philosophy on the precise meaning and “truth-conditions” for conditional sentences. The resounding agreement among specialists, is that natural languages do not use a truth-functional conditional. That is to say, real languages have a meaning to their conditional sentences, which cannot be captured in a truth-table. Therefore one should regard the conditional that we use in mathematics as a kind of “formal language” rather than a natural language.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Why <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>, rather than say <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>? Well, <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are specifically propositional variables. I want to make a claim for all possible propositions, not just the variables. So for instance, <span class="math inline">\(\alpha\)</span> could itself be <span class="math inline">\(P\to (Q\land R)\)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        return container.innerHTML
      } else {
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>